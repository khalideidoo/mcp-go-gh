// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalideidoo/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// AliasListArgs defines parameters for gh alias list
type AliasListArgs struct {
}

// RegisterAliasListTool registers the gh alias list tool
func RegisterAliasListTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_alias_list",
		Description: "List your aliases",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args AliasListArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"alias", "list"}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh alias list failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// AliasSetArgs defines parameters for gh alias set
type AliasSetArgs struct {
	Clobber bool `json:"clobber,omitempty" jsonschema:"Overwrite existing aliases of the same name"`
	Shell   bool `json:"shell,omitempty" jsonschema:"Declare an alias to be passed through a shell interpreter"`

	Alias     string `json:"alias,omitempty" jsonschema:"Alias name (positional argument)"`
	Expansion string `json:"expansion,omitempty" jsonschema:"Expansion string (positional argument)"`
}

// RegisterAliasSetTool registers the gh alias set tool
func RegisterAliasSetTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_alias_set",
		Description: "Create a shortcut for a gh command",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args AliasSetArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"alias", "set"}

		// Add positional argument: alias
		if args.Alias != "" {
			cmd = append(cmd, args.Alias)
		}

		// Add positional argument: expansion
		if args.Expansion != "" {
			cmd = append(cmd, args.Expansion)
		}

		if args.Clobber {
			cmd = append(cmd, "--clobber")
		}

		if args.Shell {
			cmd = append(cmd, "--shell")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh alias set failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// AliasDeleteArgs defines parameters for gh alias delete
type AliasDeleteArgs struct {
	All bool `json:"all,omitempty" jsonschema:"Delete all aliases"`

	Alias string `json:"alias,omitempty" jsonschema:"Alias name to delete (positional argument)"`
}

// RegisterAliasDeleteTool registers the gh alias delete tool
func RegisterAliasDeleteTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_alias_delete",
		Description: "Delete set aliases",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args AliasDeleteArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"alias", "delete"}

		// Add positional argument: alias
		if args.Alias != "" {
			cmd = append(cmd, args.Alias)
		}

		if args.All {
			cmd = append(cmd, "--all")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh alias delete failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// AliasImportArgs defines parameters for gh alias import
type AliasImportArgs struct {
	Clobber bool `json:"clobber,omitempty" jsonschema:"Overwrite existing aliases of the same name"`

	Filename string `json:"filename,omitempty" jsonschema:"Path to YAML file containing aliases (positional argument)"`
}

// RegisterAliasImportTool registers the gh alias import tool
func RegisterAliasImportTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_alias_import",
		Description: "Import aliases from a YAML file",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args AliasImportArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"alias", "import"}

		// Add positional argument: filename
		if args.Filename != "" {
			cmd = append(cmd, args.Filename)
		}

		if args.Clobber {
			cmd = append(cmd, "--clobber")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh alias import failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
