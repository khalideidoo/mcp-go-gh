// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalideidoo/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// ApiRequestArgs defines parameters for gh api request
type ApiRequestArgs struct {
	Method   string            `json:"method,omitempty" jsonschema:"description=The HTTP method for the request,enum=GET,enum=POST,enum=PUT,enum=PATCH,enum=DELETE,enum=HEAD"`
	Field    map[string]string `json:"field,omitempty" jsonschema:"description=Add typed parameter in key=value format (supports @file)"`
	RawField map[string]string `json:"raw_field,omitempty" jsonschema:"description=Add string parameter in key=value format"`
	Header   map[string]string `json:"header,omitempty" jsonschema:"description=Add HTTP request header in key:value format"`
	Input    string            `json:"input,omitempty" jsonschema:"description=The file to use as body for the HTTP request"`
	Include  bool              `json:"include,omitempty" jsonschema:"description=Include HTTP response status line and headers"`
	Silent   bool              `json:"silent,omitempty" jsonschema:"description=Do not print the response body"`
	Jq       string            `json:"jq,omitempty" jsonschema:"description=Filter JSON response using jq expression"`
	Template string            `json:"template,omitempty" jsonschema:"description=Format JSON response using Go template"`
	Paginate bool              `json:"paginate,omitempty" jsonschema:"description=Make additional HTTP requests to fetch all pages"`
	Slurp    bool              `json:"slurp,omitempty" jsonschema:"description=Use with --paginate to return array of all results"`
	Cache    string            `json:"cache,omitempty" jsonschema:"description=Cache the response for a duration"`
	Preview  []string          `json:"preview,omitempty" jsonschema:"description=GitHub API preview names to opt into"`
	Hostname string            `json:"hostname,omitempty" jsonschema:"description=GitHub hostname for Enterprise"`
	Verbose  bool              `json:"verbose,omitempty" jsonschema:"description=Include full HTTP request and response"`

	Endpoint string `json:"endpoint,omitempty" jsonschema:"description=The API endpoint path or GraphQL query (positional argument),required"`
}

// RegisterApiRequestTool registers the gh api request tool
func RegisterApiRequestTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_api_request",
		Description: "Make an authenticated HTTP request to the GitHub API and print the response",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ApiRequestArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"api", "request"}

		// Add positional argument: endpoint
		if args.Endpoint != "" {
			cmd = append(cmd, args.Endpoint)
		}

		if args.Method != "" {
			cmd = append(cmd, "--method", args.Method)
		}

		for k, v := range args.Field {
			cmd = append(cmd, "-F", fmt.Sprintf("%s=%s", k, v))
		}

		for k, v := range args.RawField {
			cmd = append(cmd, "-f", fmt.Sprintf("%s=%s", k, v))
		}

		for k, v := range args.Header {
			cmd = append(cmd, "-H", fmt.Sprintf("%s=%s", k, v))
		}

		if args.Input != "" {
			cmd = append(cmd, "--input", args.Input)
		}

		if args.Include {
			cmd = append(cmd, "--include")
		}

		if args.Silent {
			cmd = append(cmd, "--silent")
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Paginate {
			cmd = append(cmd, "--paginate")
		}

		if args.Slurp {
			cmd = append(cmd, "--slurp")
		}

		if args.Cache != "" {
			cmd = append(cmd, "--cache", args.Cache)
		}

		for _, v := range args.Preview {
			cmd = append(cmd, "--preview", v)
		}

		if args.Hostname != "" {
			cmd = append(cmd, "--hostname", args.Hostname)
		}

		if args.Verbose {
			cmd = append(cmd, "--verbose")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh api request failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
