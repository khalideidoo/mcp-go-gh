// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalideidoo/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// AttestationVerifyArgs defines parameters for gh attestation verify
type AttestationVerifyArgs struct {
	Bundle                string `json:"bundle,omitempty" jsonschema:"Path to bundle on disk for offline verification"`
	BundleFromOci         bool   `json:"bundle_from_oci,omitempty" jsonschema:"Fetch attestations from the artifact's OCI registry"`
	CertIdentity          string `json:"cert_identity,omitempty" jsonschema:"Enforce that the identity in the certificate's SAN matches the provided value"`
	CertIdentityRegex     string `json:"cert_identity_regex,omitempty" jsonschema:"Enforce that the identity in the certificate's SAN matches the provided regex"`
	CertOidcIssuer        string `json:"cert_oidc_issuer,omitempty" jsonschema:"Issuer of the OIDC token"`
	CustomTrustedRoot     string `json:"custom_trusted_root,omitempty" jsonschema:"Path to a custom trusted root file"`
	DenySelfHostedRunners bool   `json:"deny_self_hosted_runners,omitempty" jsonschema:"Fail verification for attestations generated on self-hosted runners"`
	DigestAlg             string `json:"digest_alg,omitempty" jsonschema:"Algorithm used to compute artifact digest"`
	Hostname              string `json:"hostname,omitempty" jsonschema:"Configure host to use"`
	Owner                 string `json:"owner,omitempty" jsonschema:"GitHub organization to scope attestation lookup by"`
	PredicateType         string `json:"predicate_type,omitempty" jsonschema:"Filter attestations by provided predicate type"`
	Repo                  string `json:"repo,omitempty" jsonschema:"Repository name in OWNER/REPO format"`
	SignerRepo            string `json:"signer_repo,omitempty" jsonschema:"Repository of reusable workflow that signed attestation"`
	SignerWorkflow        string `json:"signer_workflow,omitempty" jsonschema:"Path to reusable workflow that signed attestation"`

	Artifact string `json:"artifact,omitempty" jsonschema:"File path or OCI URI of artifact to verify (positional argument)"`
}

// RegisterAttestationVerifyTool registers the gh attestation verify tool
func RegisterAttestationVerifyTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_attestation_verify",
		Description: "Verify the integrity and provenance of an artifact using attestations",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args AttestationVerifyArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"attestation", "verify"}

		// Add positional argument: artifact
		if args.Artifact != "" {
			cmd = append(cmd, args.Artifact)
		}

		if args.Bundle != "" {
			cmd = append(cmd, "--bundle", args.Bundle)
		}

		if args.BundleFromOci {
			cmd = append(cmd, "--bundle-from-oci")
		}

		if args.CertIdentity != "" {
			cmd = append(cmd, "--cert-identity", args.CertIdentity)
		}

		if args.CertIdentityRegex != "" {
			cmd = append(cmd, "--cert-identity-regex", args.CertIdentityRegex)
		}

		if args.CertOidcIssuer != "" {
			cmd = append(cmd, "--cert-oidc-issuer", args.CertOidcIssuer)
		}

		if args.CustomTrustedRoot != "" {
			cmd = append(cmd, "--custom-trusted-root", args.CustomTrustedRoot)
		}

		if args.DenySelfHostedRunners {
			cmd = append(cmd, "--deny-self-hosted-runners")
		}

		if args.DigestAlg != "" {
			cmd = append(cmd, "--digest-alg", args.DigestAlg)
		}

		if args.Hostname != "" {
			cmd = append(cmd, "--hostname", args.Hostname)
		}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.PredicateType != "" {
			cmd = append(cmd, "--predicate-type", args.PredicateType)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		if args.SignerRepo != "" {
			cmd = append(cmd, "--signer-repo", args.SignerRepo)
		}

		if args.SignerWorkflow != "" {
			cmd = append(cmd, "--signer-workflow", args.SignerWorkflow)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh attestation verify failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// AttestationDownloadArgs defines parameters for gh attestation download
type AttestationDownloadArgs struct {
	DigestAlg     string `json:"digest_alg,omitempty" jsonschema:"Algorithm used to compute artifact digest"`
	Hostname      string `json:"hostname,omitempty" jsonschema:"Configure host to use"`
	Limit         int    `json:"limit,omitempty" jsonschema:"Maximum number of attestations to fetch"`
	Owner         string `json:"owner,omitempty" jsonschema:"GitHub organization to scope attestation lookup by"`
	PredicateType string `json:"predicate_type,omitempty" jsonschema:"Filter attestations by provided predicate type"`
	Repo          string `json:"repo,omitempty" jsonschema:"Repository name in OWNER/REPO format"`

	Artifact string `json:"artifact,omitempty" jsonschema:"File path or OCI URI of artifact (positional argument)"`
}

// RegisterAttestationDownloadTool registers the gh attestation download tool
func RegisterAttestationDownloadTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_attestation_download",
		Description: "Download attestations associated with an artifact for offline use",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args AttestationDownloadArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"attestation", "download"}

		// Add positional argument: artifact
		if args.Artifact != "" {
			cmd = append(cmd, args.Artifact)
		}

		if args.DigestAlg != "" {
			cmd = append(cmd, "--digest-alg", args.DigestAlg)
		}

		if args.Hostname != "" {
			cmd = append(cmd, "--hostname", args.Hostname)
		}

		if args.Limit > 0 {
			cmd = append(cmd, "--limit", fmt.Sprintf("%d", args.Limit))
		}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.PredicateType != "" {
			cmd = append(cmd, "--predicate-type", args.PredicateType)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh attestation download failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// AttestationTrustedRootArgs defines parameters for gh attestation trusted-root
type AttestationTrustedRootArgs struct {
	Hostname   string `json:"hostname,omitempty" jsonschema:"Configure host to use"`
	TufRoot    string `json:"tuf_root,omitempty" jsonschema:"Path to the TUF root.json file on disk"`
	TufUrl     string `json:"tuf_url,omitempty" jsonschema:"URL to the TUF repository mirror"`
	VerifyOnly bool   `json:"verify_only,omitempty" jsonschema:"Don't output trusted_root.jsonl contents"`
}

// RegisterAttestationTrustedRootTool registers the gh attestation trusted-root tool
func RegisterAttestationTrustedRootTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_attestation_trusted_root",
		Description: "Output trusted_root.jsonl contents for offline verification",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args AttestationTrustedRootArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"attestation", "trusted-root"}

		if args.Hostname != "" {
			cmd = append(cmd, "--hostname", args.Hostname)
		}

		if args.TufRoot != "" {
			cmd = append(cmd, "--tuf-root", args.TufRoot)
		}

		if args.TufUrl != "" {
			cmd = append(cmd, "--tuf-url", args.TufUrl)
		}

		if args.VerifyOnly {
			cmd = append(cmd, "--verify-only")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh attestation trusted-root failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
