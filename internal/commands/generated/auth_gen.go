// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalideidoo/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// AuthLoginArgs defines parameters for gh auth login
type AuthLoginArgs struct {
	Hostname    string   `json:"hostname,omitempty" jsonschema:"description=GitHub hostname"`
	GitProtocol string   `json:"git_protocol,omitempty" jsonschema:"description=Protocol for git operations,enum=https,enum=ssh"`
	Scopes      []string `json:"scopes,omitempty" jsonschema:"description=Additional authentication scopes"`
	SkipSshKey  bool     `json:"skip_ssh_key,omitempty" jsonschema:"description=Skip adding SSH key"`
	Web         bool     `json:"web,omitempty" jsonschema:"description=Open browser for authentication"`
	WithToken   bool     `json:"with_token,omitempty" jsonschema:"description=Read token from standard input"`
}

// RegisterAuthLoginTool registers the gh auth login tool
func RegisterAuthLoginTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_auth_login",
		Description: "Log in to GitHub",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args AuthLoginArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"auth", "login"}

		if args.Hostname != "" {
			cmd = append(cmd, "--hostname", args.Hostname)
		}

		if args.GitProtocol != "" {
			cmd = append(cmd, "--git-protocol", args.GitProtocol)
		}

		for _, v := range args.Scopes {
			cmd = append(cmd, "--scopes", v)
		}

		if args.SkipSshKey {
			cmd = append(cmd, "--skip-ssh-key")
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		if args.WithToken {
			cmd = append(cmd, "--with-token")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh auth login failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// AuthLogoutArgs defines parameters for gh auth logout
type AuthLogoutArgs struct {
	Hostname string `json:"hostname,omitempty" jsonschema:"description=GitHub hostname"`
	User     string `json:"user,omitempty" jsonschema:"description=GitHub username"`
}

// RegisterAuthLogoutTool registers the gh auth logout tool
func RegisterAuthLogoutTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_auth_logout",
		Description: "Log out of GitHub",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args AuthLogoutArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"auth", "logout"}

		if args.Hostname != "" {
			cmd = append(cmd, "--hostname", args.Hostname)
		}

		if args.User != "" {
			cmd = append(cmd, "--user", args.User)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh auth logout failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// AuthRefreshArgs defines parameters for gh auth refresh
type AuthRefreshArgs struct {
	Hostname              string   `json:"hostname,omitempty" jsonschema:"description=GitHub hostname"`
	InsecureStorage       bool     `json:"insecure_storage,omitempty" jsonschema:"description=Save authentication token in plain text"`
	RemoveInsecureStorage bool     `json:"remove_insecure_storage,omitempty" jsonschema:"description=Remove insecurely stored credential"`
	ResetScopes           bool     `json:"reset_scopes,omitempty" jsonschema:"description=Reset scopes to default"`
	Scopes                []string `json:"scopes,omitempty" jsonschema:"description=Additional authentication scopes"`
}

// RegisterAuthRefreshTool registers the gh auth refresh tool
func RegisterAuthRefreshTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_auth_refresh",
		Description: "Refresh stored authentication credentials",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args AuthRefreshArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"auth", "refresh"}

		if args.Hostname != "" {
			cmd = append(cmd, "--hostname", args.Hostname)
		}

		if args.InsecureStorage {
			cmd = append(cmd, "--insecure-storage")
		}

		if args.RemoveInsecureStorage {
			cmd = append(cmd, "--remove-insecure-storage")
		}

		if args.ResetScopes {
			cmd = append(cmd, "--reset-scopes")
		}

		for _, v := range args.Scopes {
			cmd = append(cmd, "--scopes", v)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh auth refresh failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// AuthStatusArgs defines parameters for gh auth status
type AuthStatusArgs struct {
	ActiveAccount bool   `json:"active_account,omitempty" jsonschema:"description=Display the active account"`
	Hostname      string `json:"hostname,omitempty" jsonschema:"description=GitHub hostname"`
	ShowToken     bool   `json:"show_token,omitempty" jsonschema:"description=Display authentication token"`
}

// RegisterAuthStatusTool registers the gh auth status tool
func RegisterAuthStatusTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_auth_status",
		Description: "View authentication status",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args AuthStatusArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"auth", "status"}

		if args.ActiveAccount {
			cmd = append(cmd, "--active-account")
		}

		if args.Hostname != "" {
			cmd = append(cmd, "--hostname", args.Hostname)
		}

		if args.ShowToken {
			cmd = append(cmd, "--show-token")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh auth status failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// AuthTokenArgs defines parameters for gh auth token
type AuthTokenArgs struct {
	Hostname string `json:"hostname,omitempty" jsonschema:"description=GitHub hostname"`
	User     string `json:"user,omitempty" jsonschema:"description=GitHub username"`
}

// RegisterAuthTokenTool registers the gh auth token tool
func RegisterAuthTokenTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_auth_token",
		Description: "Print the authentication token",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args AuthTokenArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"auth", "token"}

		if args.Hostname != "" {
			cmd = append(cmd, "--hostname", args.Hostname)
		}

		if args.User != "" {
			cmd = append(cmd, "--user", args.User)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh auth token failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// AuthSetupGitArgs defines parameters for gh auth setup_git
type AuthSetupGitArgs struct {
	Force    bool   `json:"force,omitempty" jsonschema:"description=Force setup even if already configured"`
	Hostname string `json:"hostname,omitempty" jsonschema:"description=GitHub hostname"`
}

// RegisterAuthSetupGitTool registers the gh auth setup_git tool
func RegisterAuthSetupGitTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_auth_setup_git",
		Description: "Configure git to use GitHub CLI as credential helper",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args AuthSetupGitArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"auth", "setup_git"}

		if args.Force {
			cmd = append(cmd, "--force")
		}

		if args.Hostname != "" {
			cmd = append(cmd, "--hostname", args.Hostname)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh auth setup_git failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
