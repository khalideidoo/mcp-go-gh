// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalideidoo/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// CacheListArgs defines parameters for gh cache list
type CacheListArgs struct {
	Key      string   `json:"key,omitempty" jsonschema:"Filter by cache key prefix"`
	Limit    int      `json:"limit,omitempty" jsonschema:"Maximum number of caches to fetch"`
	Order    string   `json:"order,omitempty" jsonschema:"Order of caches returned"`
	Ref      string   `json:"ref,omitempty" jsonschema:"Filter by ref (formatted as refs/heads/<branch> or refs/pull/<number>/merge)"`
	Sort     string   `json:"sort,omitempty" jsonschema:"Sort fetched caches"`
	Json     []string `json:"json,omitempty" jsonschema:"Output JSON with the specified fields"`
	Jq       string   `json:"jq,omitempty" jsonschema:"Filter JSON output using a jq expression"`
	Template string   `json:"template,omitempty" jsonschema:"Format JSON output using a Go template"`
	Repo     string   `json:"repo,omitempty" jsonschema:"Select repository in OWNER/REPO format"`
}

// RegisterCacheListTool registers the gh cache list tool
func RegisterCacheListTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_cache_list",
		Description: "List GitHub Actions caches",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args CacheListArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"cache", "list"}

		if args.Key != "" {
			cmd = append(cmd, "--key", args.Key)
		}

		if args.Limit > 0 {
			cmd = append(cmd, "--limit", fmt.Sprintf("%d", args.Limit))
		}

		if args.Order != "" {
			cmd = append(cmd, "--order", args.Order)
		}

		if args.Ref != "" {
			cmd = append(cmd, "--ref", args.Ref)
		}

		if args.Sort != "" {
			cmd = append(cmd, "--sort", args.Sort)
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh cache list failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// CacheDeleteArgs defines parameters for gh cache delete
type CacheDeleteArgs struct {
	All               bool   `json:"all,omitempty" jsonschema:"Delete all caches"`
	Ref               string `json:"ref,omitempty" jsonschema:"Delete by cache key and ref (formatted as refs/heads/<branch> or refs/pull/<number>/merge)"`
	SucceedOnNoCaches bool   `json:"succeed_on_no_caches,omitempty" jsonschema:"Return exit code 0 if no caches found (must be used with --all)"`
	Repo              string `json:"repo,omitempty" jsonschema:"Select repository in OWNER/REPO format"`

	CacheId string `json:"cache_id,omitempty" jsonschema:"Cache ID or cache key (positional argument)"`
}

// RegisterCacheDeleteTool registers the gh cache delete tool
func RegisterCacheDeleteTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_cache_delete",
		Description: "Delete GitHub Actions caches",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args CacheDeleteArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"cache", "delete"}

		// Add positional argument: cache_id
		if args.CacheId != "" {
			cmd = append(cmd, args.CacheId)
		}

		if args.All {
			cmd = append(cmd, "--all")
		}

		if args.Ref != "" {
			cmd = append(cmd, "--ref", args.Ref)
		}

		if args.SucceedOnNoCaches {
			cmd = append(cmd, "--succeed-on-no-caches")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh cache delete failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
