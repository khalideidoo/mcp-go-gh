// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalideidoo/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// CodespaceListArgs defines parameters for gh codespace list
type CodespaceListArgs struct {
	Jq       string   `json:"jq,omitempty" jsonschema:"Filter JSON output using a jq expression"`
	Json     []string `json:"json,omitempty" jsonschema:"Output JSON with the specified fields"`
	Limit    int      `json:"limit,omitempty" jsonschema:"Maximum number of codespaces to list"`
	Org      string   `json:"org,omitempty" jsonschema:"The login handle of the organization to list codespaces for (admin-only)"`
	Repo     string   `json:"repo,omitempty" jsonschema:"Repository name with owner (user/repo)"`
	Template string   `json:"template,omitempty" jsonschema:"Format JSON output using a Go template"`
	User     string   `json:"user,omitempty" jsonschema:"The username to list codespaces for (used with --org)"`
	Web      bool     `json:"web,omitempty" jsonschema:"List codespaces in the web browser"`
}

// RegisterCodespaceListTool registers the gh codespace list tool
func RegisterCodespaceListTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_codespace_list",
		Description: "List codespaces of the authenticated user",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args CodespaceListArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"codespace", "list"}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Limit > 0 {
			cmd = append(cmd, "--limit", fmt.Sprintf("%d", args.Limit))
		}

		if args.Org != "" {
			cmd = append(cmd, "--org", args.Org)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.User != "" {
			cmd = append(cmd, "--user", args.User)
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh codespace list failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// CodespaceCreateArgs defines parameters for gh codespace create
type CodespaceCreateArgs struct {
	Branch             string `json:"branch,omitempty" jsonschema:"Repository branch"`
	DefaultPermissions bool   `json:"default_permissions,omitempty" jsonschema:"Do not prompt to accept additional permissions requested by the codespace"`
	DevcontainerPath   string `json:"devcontainer_path,omitempty" jsonschema:"Path to the devcontainer.json file to use when creating codespace"`
	DisplayName        string `json:"display_name,omitempty" jsonschema:"Display name for the codespace (48 characters or less)"`
	IdleTimeout        string `json:"idle_timeout,omitempty" jsonschema:"Allowed inactivity before codespace is stopped (e.g. '10m', '1h')"`
	Location           string `json:"location,omitempty" jsonschema:"Location (EastUs|SouthEastAsia|WestEurope|WestUs2)"`
	Machine            string `json:"machine,omitempty" jsonschema:"Hardware specifications for the VM"`
	Repo               string `json:"repo,omitempty" jsonschema:"Repository name with owner (user/repo)"`
	RetentionPeriod    string `json:"retention_period,omitempty" jsonschema:"Allowed time after shutting down before auto-deletion (e.g. '1h', '72h')"`
	Status             bool   `json:"status,omitempty" jsonschema:"Show status of post-create command and dotfiles"`
	Web                bool   `json:"web,omitempty" jsonschema:"Create codespace from browser"`
}

// RegisterCodespaceCreateTool registers the gh codespace create tool
func RegisterCodespaceCreateTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_codespace_create",
		Description: "Create a codespace",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args CodespaceCreateArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"codespace", "create"}

		if args.Branch != "" {
			cmd = append(cmd, "--branch", args.Branch)
		}

		if args.DefaultPermissions {
			cmd = append(cmd, "--default-permissions")
		}

		if args.DevcontainerPath != "" {
			cmd = append(cmd, "--devcontainer-path", args.DevcontainerPath)
		}

		if args.DisplayName != "" {
			cmd = append(cmd, "--display-name", args.DisplayName)
		}

		if args.IdleTimeout != "" {
			cmd = append(cmd, "--idle-timeout", args.IdleTimeout)
		}

		if args.Location != "" {
			cmd = append(cmd, "--location", args.Location)
		}

		if args.Machine != "" {
			cmd = append(cmd, "--machine", args.Machine)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		if args.RetentionPeriod != "" {
			cmd = append(cmd, "--retention-period", args.RetentionPeriod)
		}

		if args.Status {
			cmd = append(cmd, "--status")
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh codespace create failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// CodespaceDeleteArgs defines parameters for gh codespace delete
type CodespaceDeleteArgs struct {
	All       bool   `json:"all,omitempty" jsonschema:"Delete all codespaces"`
	Codespace string `json:"codespace,omitempty" jsonschema:"Name of the codespace"`
	Days      int    `json:"days,omitempty" jsonschema:"Delete codespaces older than N days"`
	Force     bool   `json:"force,omitempty" jsonschema:"Skip confirmation for codespaces that contain unsaved changes"`
	Org       string `json:"org,omitempty" jsonschema:"The login handle of the organization (admin-only)"`
	Repo      string `json:"repo,omitempty" jsonschema:"Filter codespace selection by repository name (user/repo)"`
	RepoOwner string `json:"repo_owner,omitempty" jsonschema:"Filter codespace selection by repository owner"`
	User      string `json:"user,omitempty" jsonschema:"The username to delete codespaces for (used with --org)"`
}

// RegisterCodespaceDeleteTool registers the gh codespace delete tool
func RegisterCodespaceDeleteTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_codespace_delete",
		Description: "Delete codespaces based on selection criteria",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args CodespaceDeleteArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"codespace", "delete"}

		if args.All {
			cmd = append(cmd, "--all")
		}

		if args.Codespace != "" {
			cmd = append(cmd, "--codespace", args.Codespace)
		}

		if args.Days > 0 {
			cmd = append(cmd, "--days", fmt.Sprintf("%d", args.Days))
		}

		if args.Force {
			cmd = append(cmd, "--force")
		}

		if args.Org != "" {
			cmd = append(cmd, "--org", args.Org)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		if args.RepoOwner != "" {
			cmd = append(cmd, "--repo-owner", args.RepoOwner)
		}

		if args.User != "" {
			cmd = append(cmd, "--user", args.User)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh codespace delete failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// CodespaceViewArgs defines parameters for gh codespace view
type CodespaceViewArgs struct {
	Codespace string   `json:"codespace,omitempty" jsonschema:"Name of the codespace"`
	Jq        string   `json:"jq,omitempty" jsonschema:"Filter JSON output using a jq expression"`
	Json      []string `json:"json,omitempty" jsonschema:"Output JSON with the specified fields"`
	Repo      string   `json:"repo,omitempty" jsonschema:"Filter codespace selection by repository name (user/repo)"`
	RepoOwner string   `json:"repo_owner,omitempty" jsonschema:"Filter codespace selection by repository owner"`
	Template  string   `json:"template,omitempty" jsonschema:"Format JSON output using a Go template"`
}

// RegisterCodespaceViewTool registers the gh codespace view tool
func RegisterCodespaceViewTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_codespace_view",
		Description: "View details about a codespace",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args CodespaceViewArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"codespace", "view"}

		if args.Codespace != "" {
			cmd = append(cmd, "--codespace", args.Codespace)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		if args.RepoOwner != "" {
			cmd = append(cmd, "--repo-owner", args.RepoOwner)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh codespace view failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// CodespaceStopArgs defines parameters for gh codespace stop
type CodespaceStopArgs struct {
	Codespace string `json:"codespace,omitempty" jsonschema:"Name of the codespace"`
	Org       string `json:"org,omitempty" jsonschema:"The login handle of the organization (admin-only)"`
	Repo      string `json:"repo,omitempty" jsonschema:"Filter codespace selection by repository name (user/repo)"`
	RepoOwner string `json:"repo_owner,omitempty" jsonschema:"Filter codespace selection by repository owner"`
	User      string `json:"user,omitempty" jsonschema:"The username to stop codespace for (used with --org)"`
}

// RegisterCodespaceStopTool registers the gh codespace stop tool
func RegisterCodespaceStopTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_codespace_stop",
		Description: "Stop a running codespace",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args CodespaceStopArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"codespace", "stop"}

		if args.Codespace != "" {
			cmd = append(cmd, "--codespace", args.Codespace)
		}

		if args.Org != "" {
			cmd = append(cmd, "--org", args.Org)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		if args.RepoOwner != "" {
			cmd = append(cmd, "--repo-owner", args.RepoOwner)
		}

		if args.User != "" {
			cmd = append(cmd, "--user", args.User)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh codespace stop failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// CodespaceSshArgs defines parameters for gh codespace ssh
type CodespaceSshArgs struct {
	Codespace  string `json:"codespace,omitempty" jsonschema:"Name of the codespace"`
	Config     bool   `json:"config,omitempty" jsonschema:"Write OpenSSH configuration to stdout"`
	Debug      bool   `json:"debug,omitempty" jsonschema:"Log debug data to a file"`
	DebugFile  string `json:"debug_file,omitempty" jsonschema:"Path of the file log to"`
	Profile    string `json:"profile,omitempty" jsonschema:"Name of the SSH profile to use"`
	Repo       string `json:"repo,omitempty" jsonschema:"Filter codespace selection by repository name (user/repo)"`
	RepoOwner  string `json:"repo_owner,omitempty" jsonschema:"Filter codespace selection by repository owner"`
	ServerPort int    `json:"server_port,omitempty" jsonschema:"SSH server port number (0 => pick unused)"`
}

// RegisterCodespaceSshTool registers the gh codespace ssh tool
func RegisterCodespaceSshTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_codespace_ssh",
		Description: "SSH into a codespace",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args CodespaceSshArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"codespace", "ssh"}

		if args.Codespace != "" {
			cmd = append(cmd, "--codespace", args.Codespace)
		}

		if args.Config {
			cmd = append(cmd, "--config")
		}

		if args.Debug {
			cmd = append(cmd, "--debug")
		}

		if args.DebugFile != "" {
			cmd = append(cmd, "--debug-file", args.DebugFile)
		}

		if args.Profile != "" {
			cmd = append(cmd, "--profile", args.Profile)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		if args.RepoOwner != "" {
			cmd = append(cmd, "--repo-owner", args.RepoOwner)
		}

		if args.ServerPort > 0 {
			cmd = append(cmd, "--server-port", fmt.Sprintf("%d", args.ServerPort))
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh codespace ssh failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// CodespaceLogsArgs defines parameters for gh codespace logs
type CodespaceLogsArgs struct {
	Codespace string `json:"codespace,omitempty" jsonschema:"Name of the codespace"`
	Follow    bool   `json:"follow,omitempty" jsonschema:"Tail and follow the logs"`
	Repo      string `json:"repo,omitempty" jsonschema:"Filter codespace selection by repository name (user/repo)"`
	RepoOwner string `json:"repo_owner,omitempty" jsonschema:"Filter codespace selection by repository owner"`
}

// RegisterCodespaceLogsTool registers the gh codespace logs tool
func RegisterCodespaceLogsTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_codespace_logs",
		Description: "Access codespace logs",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args CodespaceLogsArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"codespace", "logs"}

		if args.Codespace != "" {
			cmd = append(cmd, "--codespace", args.Codespace)
		}

		if args.Follow {
			cmd = append(cmd, "--follow")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		if args.RepoOwner != "" {
			cmd = append(cmd, "--repo-owner", args.RepoOwner)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh codespace logs failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// CodespacePortsArgs defines parameters for gh codespace ports
type CodespacePortsArgs struct {
	Codespace string   `json:"codespace,omitempty" jsonschema:"Name of the codespace"`
	Jq        string   `json:"jq,omitempty" jsonschema:"Filter JSON output using a jq expression"`
	Json      []string `json:"json,omitempty" jsonschema:"Output JSON with the specified fields"`
	Repo      string   `json:"repo,omitempty" jsonschema:"Filter codespace selection by repository name (user/repo)"`
	RepoOwner string   `json:"repo_owner,omitempty" jsonschema:"Filter codespace selection by repository owner"`
	Template  string   `json:"template,omitempty" jsonschema:"Format JSON output using a Go template"`
}

// RegisterCodespacePortsTool registers the gh codespace ports tool
func RegisterCodespacePortsTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_codespace_ports",
		Description: "List ports in a codespace",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args CodespacePortsArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"codespace", "ports"}

		if args.Codespace != "" {
			cmd = append(cmd, "--codespace", args.Codespace)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		if args.RepoOwner != "" {
			cmd = append(cmd, "--repo-owner", args.RepoOwner)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh codespace ports failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// CodespaceEditArgs defines parameters for gh codespace edit
type CodespaceEditArgs struct {
	Codespace   string `json:"codespace,omitempty" jsonschema:"Name of the codespace"`
	DisplayName string `json:"display_name,omitempty" jsonschema:"Set the display name"`
	Machine     string `json:"machine,omitempty" jsonschema:"Set hardware specifications for the VM"`
	Repo        string `json:"repo,omitempty" jsonschema:"Filter codespace selection by repository name (user/repo)"`
	RepoOwner   string `json:"repo_owner,omitempty" jsonschema:"Filter codespace selection by repository owner"`
}

// RegisterCodespaceEditTool registers the gh codespace edit tool
func RegisterCodespaceEditTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_codespace_edit",
		Description: "Edit a codespace",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args CodespaceEditArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"codespace", "edit"}

		if args.Codespace != "" {
			cmd = append(cmd, "--codespace", args.Codespace)
		}

		if args.DisplayName != "" {
			cmd = append(cmd, "--display-name", args.DisplayName)
		}

		if args.Machine != "" {
			cmd = append(cmd, "--machine", args.Machine)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		if args.RepoOwner != "" {
			cmd = append(cmd, "--repo-owner", args.RepoOwner)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh codespace edit failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// CodespaceRebuildArgs defines parameters for gh codespace rebuild
type CodespaceRebuildArgs struct {
	Codespace string `json:"codespace,omitempty" jsonschema:"Name of the codespace"`
	Full      bool   `json:"full,omitempty" jsonschema:"Perform a full rebuild"`
	Repo      string `json:"repo,omitempty" jsonschema:"Filter codespace selection by repository name (user/repo)"`
	RepoOwner string `json:"repo_owner,omitempty" jsonschema:"Filter codespace selection by repository owner"`
}

// RegisterCodespaceRebuildTool registers the gh codespace rebuild tool
func RegisterCodespaceRebuildTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_codespace_rebuild",
		Description: "Rebuild a codespace",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args CodespaceRebuildArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"codespace", "rebuild"}

		if args.Codespace != "" {
			cmd = append(cmd, "--codespace", args.Codespace)
		}

		if args.Full {
			cmd = append(cmd, "--full")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		if args.RepoOwner != "" {
			cmd = append(cmd, "--repo-owner", args.RepoOwner)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh codespace rebuild failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// CodespaceCodeArgs defines parameters for gh codespace code
type CodespaceCodeArgs struct {
	Codespace string `json:"codespace,omitempty" jsonschema:"Name of the codespace"`
	Insiders  bool   `json:"insiders,omitempty" jsonschema:"Use the insiders version of Visual Studio Code"`
	Repo      string `json:"repo,omitempty" jsonschema:"Filter codespace selection by repository name (user/repo)"`
	RepoOwner string `json:"repo_owner,omitempty" jsonschema:"Filter codespace selection by repository owner"`
	Web       bool   `json:"web,omitempty" jsonschema:"Use the web version of Visual Studio Code"`
}

// RegisterCodespaceCodeTool registers the gh codespace code tool
func RegisterCodespaceCodeTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_codespace_code",
		Description: "Open a codespace in Visual Studio Code",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args CodespaceCodeArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"codespace", "code"}

		if args.Codespace != "" {
			cmd = append(cmd, "--codespace", args.Codespace)
		}

		if args.Insiders {
			cmd = append(cmd, "--insiders")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		if args.RepoOwner != "" {
			cmd = append(cmd, "--repo-owner", args.RepoOwner)
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh codespace code failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// CodespaceJupyterArgs defines parameters for gh codespace jupyter
type CodespaceJupyterArgs struct {
	Codespace string `json:"codespace,omitempty" jsonschema:"Name of the codespace"`
	Repo      string `json:"repo,omitempty" jsonschema:"Filter codespace selection by repository name (user/repo)"`
	RepoOwner string `json:"repo_owner,omitempty" jsonschema:"Filter codespace selection by repository owner"`
}

// RegisterCodespaceJupyterTool registers the gh codespace jupyter tool
func RegisterCodespaceJupyterTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_codespace_jupyter",
		Description: "Open a codespace in JupyterLab",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args CodespaceJupyterArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"codespace", "jupyter"}

		if args.Codespace != "" {
			cmd = append(cmd, "--codespace", args.Codespace)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		if args.RepoOwner != "" {
			cmd = append(cmd, "--repo-owner", args.RepoOwner)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh codespace jupyter failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// CodespaceCpArgs defines parameters for gh codespace cp
type CodespaceCpArgs struct {
	Codespace string `json:"codespace,omitempty" jsonschema:"Name of the codespace"`
	Expand    bool   `json:"expand,omitempty" jsonschema:"Expand remote file names on remote shell"`
	Profile   string `json:"profile,omitempty" jsonschema:"Name of the SSH profile to use"`
	Recursive bool   `json:"recursive,omitempty" jsonschema:"Recursively copy directories"`
	Repo      string `json:"repo,omitempty" jsonschema:"Filter codespace selection by repository name (user/repo)"`
	RepoOwner string `json:"repo_owner,omitempty" jsonschema:"Filter codespace selection by repository owner"`

	Sources []string `json:"sources,omitempty" jsonschema:"Source paths (positional arguments)"`
}

// RegisterCodespaceCpTool registers the gh codespace cp tool
func RegisterCodespaceCpTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_codespace_cp",
		Description: "Copy files between local and remote file systems",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args CodespaceCpArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"codespace", "cp"}

		// Add positional argument: sources
		cmd = append(cmd, args.Sources...)

		if args.Codespace != "" {
			cmd = append(cmd, "--codespace", args.Codespace)
		}

		if args.Expand {
			cmd = append(cmd, "--expand")
		}

		if args.Profile != "" {
			cmd = append(cmd, "--profile", args.Profile)
		}

		if args.Recursive {
			cmd = append(cmd, "--recursive")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		if args.RepoOwner != "" {
			cmd = append(cmd, "--repo-owner", args.RepoOwner)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh codespace cp failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
