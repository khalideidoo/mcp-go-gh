// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalideidoo/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// ConfigListArgs defines parameters for gh config list
type ConfigListArgs struct {
	Host string `json:"host,omitempty" jsonschema:"Get per-host configuration"`
}

// RegisterConfigListTool registers the gh config list tool
func RegisterConfigListTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_config_list",
		Description: "Print a list of configuration keys and values",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ConfigListArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"config", "list"}

		if args.Host != "" {
			cmd = append(cmd, "--host", args.Host)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh config list failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ConfigGetArgs defines parameters for gh config get
type ConfigGetArgs struct {
	Host string `json:"host,omitempty" jsonschema:"Get per-host setting"`

	Key string `json:"key,omitempty" jsonschema:"Configuration key (positional argument)"`
}

// RegisterConfigGetTool registers the gh config get tool
func RegisterConfigGetTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_config_get",
		Description: "Print the value of a given configuration key",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ConfigGetArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"config", "get"}

		// Add positional argument: key
		if args.Key != "" {
			cmd = append(cmd, args.Key)
		}

		if args.Host != "" {
			cmd = append(cmd, "--host", args.Host)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh config get failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ConfigSetArgs defines parameters for gh config set
type ConfigSetArgs struct {
	Host string `json:"host,omitempty" jsonschema:"Set per-host setting"`

	Key   string `json:"key,omitempty" jsonschema:"Configuration key (positional argument)"`
	Value string `json:"value,omitempty" jsonschema:"Configuration value (positional argument)"`
}

// RegisterConfigSetTool registers the gh config set tool
func RegisterConfigSetTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_config_set",
		Description: "Update configuration with a value for the given key",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ConfigSetArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"config", "set"}

		// Add positional argument: key
		if args.Key != "" {
			cmd = append(cmd, args.Key)
		}

		// Add positional argument: value
		if args.Value != "" {
			cmd = append(cmd, args.Value)
		}

		if args.Host != "" {
			cmd = append(cmd, "--host", args.Host)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh config set failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ConfigClearCacheArgs defines parameters for gh config clear-cache
type ConfigClearCacheArgs struct {
}

// RegisterConfigClearCacheTool registers the gh config clear-cache tool
func RegisterConfigClearCacheTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_config_clear_cache",
		Description: "Clear the cli cache",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ConfigClearCacheArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"config", "clear-cache"}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh config clear-cache failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
