// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalideidoo/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// ExtensionListArgs defines parameters for gh extension list
type ExtensionListArgs struct {
}

// RegisterExtensionListTool registers the gh extension list tool
func RegisterExtensionListTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_extension_list",
		Description: "List installed extension commands",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ExtensionListArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"extension", "list"}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh extension list failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ExtensionInstallArgs defines parameters for gh extension install
type ExtensionInstallArgs struct {
	Force bool   `json:"force,omitempty" jsonschema:"description=Force upgrade extension, or ignore if latest already installed"`
	Pin   string `json:"pin,omitempty" jsonschema:"description=Pin extension to a release tag or commit ref"`

	Repository string `json:"repository,omitempty" jsonschema:"description=Repository in OWNER/REPO format or URL (positional argument),required"`
}

// RegisterExtensionInstallTool registers the gh extension install tool
func RegisterExtensionInstallTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_extension_install",
		Description: "Install a gh extension from a repository",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ExtensionInstallArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"extension", "install"}

		// Add positional argument: repository
		if args.Repository != "" {
			cmd = append(cmd, args.Repository)
		}

		if args.Force {
			cmd = append(cmd, "--force")
		}

		if args.Pin != "" {
			cmd = append(cmd, "--pin", args.Pin)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh extension install failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ExtensionRemoveArgs defines parameters for gh extension remove
type ExtensionRemoveArgs struct {
	Name string `json:"name,omitempty" jsonschema:"description=Name of the extension (positional argument),required"`
}

// RegisterExtensionRemoveTool registers the gh extension remove tool
func RegisterExtensionRemoveTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_extension_remove",
		Description: "Remove an installed extension",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ExtensionRemoveArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"extension", "remove"}

		// Add positional argument: name
		if args.Name != "" {
			cmd = append(cmd, args.Name)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh extension remove failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ExtensionUpgradeArgs defines parameters for gh extension upgrade
type ExtensionUpgradeArgs struct {
	All    bool `json:"all,omitempty" jsonschema:"description=Upgrade all extensions"`
	DryRun bool `json:"dry_run,omitempty" jsonschema:"description=Only display upgrades"`
	Force  bool `json:"force,omitempty" jsonschema:"description=Force upgrade extension"`

	Name string `json:"name,omitempty" jsonschema:"description=Name of the extension to upgrade (positional argument)"`
}

// RegisterExtensionUpgradeTool registers the gh extension upgrade tool
func RegisterExtensionUpgradeTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_extension_upgrade",
		Description: "Upgrade installed extensions",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ExtensionUpgradeArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"extension", "upgrade"}

		// Add positional argument: name
		if args.Name != "" {
			cmd = append(cmd, args.Name)
		}

		if args.All {
			cmd = append(cmd, "--all")
		}

		if args.DryRun {
			cmd = append(cmd, "--dry-run")
		}

		if args.Force {
			cmd = append(cmd, "--force")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh extension upgrade failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ExtensionSearchArgs defines parameters for gh extension search
type ExtensionSearchArgs struct {
	License  []string `json:"license,omitempty" jsonschema:"description=Filter based on license type"`
	Limit    int      `json:"limit,omitempty" jsonschema:"description=Maximum number of extensions to fetch"`
	Order    string   `json:"order,omitempty" jsonschema:"description=Order of repositories returned,enum=asc,enum=desc"`
	Owner    []string `json:"owner,omitempty" jsonschema:"description=Filter on owner"`
	Sort     string   `json:"sort,omitempty" jsonschema:"description=Sort fetched repositories,enum=forks,enum=help-wanted-issues,enum=stars,enum=updated,enum=best-match"`
	Json     []string `json:"json,omitempty" jsonschema:"description=Output JSON with the specified fields"`
	Jq       string   `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Template string   `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`
	Web      bool     `json:"web,omitempty" jsonschema:"description=Open the search query in the web browser"`

	Query string `json:"query,omitempty" jsonschema:"description=Search query (positional argument)"`
}

// RegisterExtensionSearchTool registers the gh extension search tool
func RegisterExtensionSearchTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_extension_search",
		Description: "Search for gh extensions",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ExtensionSearchArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"extension", "search"}

		// Add positional argument: query
		if args.Query != "" {
			cmd = append(cmd, args.Query)
		}

		for _, v := range args.License {
			cmd = append(cmd, "--license", v)
		}

		if args.Limit > 0 {
			cmd = append(cmd, "--limit", fmt.Sprintf("%d", args.Limit))
		}

		if args.Order != "" {
			cmd = append(cmd, "--order", args.Order)
		}

		for _, v := range args.Owner {
			cmd = append(cmd, "--owner", v)
		}

		if args.Sort != "" {
			cmd = append(cmd, "--sort", args.Sort)
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh extension search failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ExtensionCreateArgs defines parameters for gh extension create
type ExtensionCreateArgs struct {
	Precompiled string `json:"precompiled,omitempty" jsonschema:"description=Create a precompiled extension,enum=go,enum=other"`

	Name string `json:"name,omitempty" jsonschema:"description=Name of the extension (positional argument)"`
}

// RegisterExtensionCreateTool registers the gh extension create tool
func RegisterExtensionCreateTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_extension_create",
		Description: "Create a new extension",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ExtensionCreateArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"extension", "create"}

		// Add positional argument: name
		if args.Name != "" {
			cmd = append(cmd, args.Name)
		}

		if args.Precompiled != "" {
			cmd = append(cmd, "--precompiled", args.Precompiled)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh extension create failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ExtensionExecArgs defines parameters for gh extension exec
type ExtensionExecArgs struct {
	Name string `json:"name,omitempty" jsonschema:"description=Name of the extension to execute (positional argument),required"`
}

// RegisterExtensionExecTool registers the gh extension exec tool
func RegisterExtensionExecTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_extension_exec",
		Description: "Execute an installed extension",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ExtensionExecArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"extension", "exec"}

		// Add positional argument: name
		if args.Name != "" {
			cmd = append(cmd, args.Name)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh extension exec failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ExtensionBrowseArgs defines parameters for gh extension browse
type ExtensionBrowseArgs struct {
}

// RegisterExtensionBrowseTool registers the gh extension browse tool
func RegisterExtensionBrowseTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_extension_browse",
		Description: "Enter a UI for browsing, adding, and removing extensions",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ExtensionBrowseArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"extension", "browse"}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh extension browse failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
