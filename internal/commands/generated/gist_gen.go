// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalideidoo/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// GistCreateArgs defines parameters for gh gist create
type GistCreateArgs struct {
	Desc     string `json:"desc,omitempty" jsonschema:"description=Description for the gist"`
	Filename string `json:"filename,omitempty" jsonschema:"description=Provide a filename for stdin content"`
	Public   bool   `json:"public,omitempty" jsonschema:"description=List the gist publicly"`
	Web      bool   `json:"web,omitempty" jsonschema:"description=Open in web browser"`

	Files []string `json:"files,omitempty" jsonschema:"description=Files to include in gist (positional arguments)"`
}

// RegisterGistCreateTool registers the gh gist create tool
func RegisterGistCreateTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_gist_create",
		Description: "Create a new gist",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args GistCreateArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"gist", "create"}

		// Add positional argument: files
		cmd = append(cmd, args.Files...)

		if args.Desc != "" {
			cmd = append(cmd, "--desc", args.Desc)
		}

		if args.Filename != "" {
			cmd = append(cmd, "--filename", args.Filename)
		}

		if args.Public {
			cmd = append(cmd, "--public")
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh gist create failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// GistListArgs defines parameters for gh gist list
type GistListArgs struct {
	Limit    int      `json:"limit,omitempty" jsonschema:"description=Maximum number of gists to fetch"`
	Public   bool     `json:"public,omitempty" jsonschema:"description=Show only public gists"`
	Secret   bool     `json:"secret,omitempty" jsonschema:"description=Show only secret gists"`
	Json     []string `json:"json,omitempty" jsonschema:"description=Output JSON with the specified fields"`
	Jq       string   `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Template string   `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`
}

// RegisterGistListTool registers the gh gist list tool
func RegisterGistListTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_gist_list",
		Description: "List gists owned by user",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args GistListArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"gist", "list"}

		if args.Limit > 0 {
			cmd = append(cmd, "--limit", fmt.Sprintf("%d", args.Limit))
		}

		if args.Public {
			cmd = append(cmd, "--public")
		}

		if args.Secret {
			cmd = append(cmd, "--secret")
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh gist list failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// GistViewArgs defines parameters for gh gist view
type GistViewArgs struct {
	Filename string `json:"filename,omitempty" jsonschema:"description=Display a single file from the gist"`
	Files    bool   `json:"files,omitempty" jsonschema:"description=List file names from the gist"`
	Raw      bool   `json:"raw,omitempty" jsonschema:"description=Print raw instead of rendered gist contents"`
	Web      bool   `json:"web,omitempty" jsonschema:"description=Open gist in the browser"`

	Gist string `json:"gist,omitempty" jsonschema:"description=Gist ID or URL (positional argument),required"`
}

// RegisterGistViewTool registers the gh gist view tool
func RegisterGistViewTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_gist_view",
		Description: "View a gist",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args GistViewArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"gist", "view"}

		// Add positional argument: gist
		if args.Gist != "" {
			cmd = append(cmd, args.Gist)
		}

		if args.Filename != "" {
			cmd = append(cmd, "--filename", args.Filename)
		}

		if args.Files {
			cmd = append(cmd, "--files")
		}

		if args.Raw {
			cmd = append(cmd, "--raw")
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh gist view failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// GistEditArgs defines parameters for gh gist edit
type GistEditArgs struct {
	Add      []string `json:"add,omitempty" jsonschema:"description=Add a new file to the gist"`
	Desc     string   `json:"desc,omitempty" jsonschema:"description=New description for the gist"`
	Filename string   `json:"filename,omitempty" jsonschema:"description=Select a file to edit"`
	Remove   []string `json:"remove,omitempty" jsonschema:"description=Remove a file from the gist"`

	Gist string `json:"gist,omitempty" jsonschema:"description=Gist ID or URL (positional argument),required"`
}

// RegisterGistEditTool registers the gh gist edit tool
func RegisterGistEditTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_gist_edit",
		Description: "Edit a gist",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args GistEditArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"gist", "edit"}

		// Add positional argument: gist
		if args.Gist != "" {
			cmd = append(cmd, args.Gist)
		}

		for _, v := range args.Add {
			cmd = append(cmd, "--add", v)
		}

		if args.Desc != "" {
			cmd = append(cmd, "--desc", args.Desc)
		}

		if args.Filename != "" {
			cmd = append(cmd, "--filename", args.Filename)
		}

		for _, v := range args.Remove {
			cmd = append(cmd, "--remove", v)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh gist edit failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// GistDeleteArgs defines parameters for gh gist delete
type GistDeleteArgs struct {
	Gist string `json:"gist,omitempty" jsonschema:"description=Gist ID or URL (positional argument),required"`
}

// RegisterGistDeleteTool registers the gh gist delete tool
func RegisterGistDeleteTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_gist_delete",
		Description: "Delete a gist",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args GistDeleteArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"gist", "delete"}

		// Add positional argument: gist
		if args.Gist != "" {
			cmd = append(cmd, args.Gist)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh gist delete failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// GistCloneArgs defines parameters for gh gist clone
type GistCloneArgs struct {
	Gist      string `json:"gist,omitempty" jsonschema:"description=Gist ID or URL (positional argument),required"`
	Directory string `json:"directory,omitempty" jsonschema:"description=Directory to clone into (positional argument)"`
}

// RegisterGistCloneTool registers the gh gist clone tool
func RegisterGistCloneTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_gist_clone",
		Description: "Clone a gist locally",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args GistCloneArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"gist", "clone"}

		// Add positional argument: gist
		if args.Gist != "" {
			cmd = append(cmd, args.Gist)
		}

		// Add positional argument: directory
		if args.Directory != "" {
			cmd = append(cmd, args.Directory)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh gist clone failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
