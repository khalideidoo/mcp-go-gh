// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalideidoo/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// IssueCreateArgs defines parameters for gh issue create
type IssueCreateArgs struct {
	Title     string   `json:"title,omitempty" jsonschema:"description=Title for the issue"`
	Body      string   `json:"body,omitempty" jsonschema:"description=Body text for the issue"`
	BodyFile  string   `json:"body_file,omitempty" jsonschema:"description=Read body text from file (use - for stdin)"`
	Assignee  []string `json:"assignee,omitempty" jsonschema:"description=Assign people by their login (use @me for self)"`
	Label     []string `json:"label,omitempty" jsonschema:"description=Add labels by name"`
	Milestone string   `json:"milestone,omitempty" jsonschema:"description=Add the issue to a milestone by name"`
	Project   []string `json:"project,omitempty" jsonschema:"description=Add the issue to projects by title"`
	Template  string   `json:"template,omitempty" jsonschema:"description=Template file to use as starting body text"`
	Web       bool     `json:"web,omitempty" jsonschema:"description=Open the web browser to create an issue"`
	Recover   string   `json:"recover,omitempty" jsonschema:"description=Recover input from a failed run"`
	Repo      string   `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`
}

// RegisterIssueCreateTool registers the gh issue create tool
func RegisterIssueCreateTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_issue_create",
		Description: "Create a new issue",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args IssueCreateArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"issue", "create"}

		if args.Title != "" {
			cmd = append(cmd, "--title", args.Title)
		}

		if args.Body != "" {
			cmd = append(cmd, "--body", args.Body)
		}

		if args.BodyFile != "" {
			cmd = append(cmd, "--body-file", args.BodyFile)
		}

		for _, v := range args.Assignee {
			cmd = append(cmd, "--assignee", v)
		}

		for _, v := range args.Label {
			cmd = append(cmd, "--label", v)
		}

		if args.Milestone != "" {
			cmd = append(cmd, "--milestone", args.Milestone)
		}

		for _, v := range args.Project {
			cmd = append(cmd, "--project", v)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		if args.Recover != "" {
			cmd = append(cmd, "--recover", args.Recover)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh issue create failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// IssueListArgs defines parameters for gh issue list
type IssueListArgs struct {
	Assignee  string   `json:"assignee,omitempty" jsonschema:"description=Filter by assignee"`
	Author    string   `json:"author,omitempty" jsonschema:"description=Filter by author"`
	Label     []string `json:"label,omitempty" jsonschema:"description=Filter by label"`
	Mention   string   `json:"mention,omitempty" jsonschema:"description=Filter by mention of a user"`
	Milestone string   `json:"milestone,omitempty" jsonschema:"description=Filter by milestone number or title"`
	State     string   `json:"state,omitempty" jsonschema:"description=Filter by state,enum=open,enum=closed,enum=all"`
	Search    string   `json:"search,omitempty" jsonschema:"description=Search issues with a query"`
	App       string   `json:"app,omitempty" jsonschema:"description=Filter by GitHub App author"`
	Limit     int      `json:"limit,omitempty" jsonschema:"description=Maximum number of items to fetch"`
	Json      []string `json:"json,omitempty" jsonschema:"description=Output JSON with the specified fields"`
	Jq        string   `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Template  string   `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`
	Web       bool     `json:"web,omitempty" jsonschema:"description=List issues in the web browser"`
	Repo      string   `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`
}

// RegisterIssueListTool registers the gh issue list tool
func RegisterIssueListTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_issue_list",
		Description: "List issues in a repository",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args IssueListArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"issue", "list"}

		if args.Assignee != "" {
			cmd = append(cmd, "--assignee", args.Assignee)
		}

		if args.Author != "" {
			cmd = append(cmd, "--author", args.Author)
		}

		for _, v := range args.Label {
			cmd = append(cmd, "--label", v)
		}

		if args.Mention != "" {
			cmd = append(cmd, "--mention", args.Mention)
		}

		if args.Milestone != "" {
			cmd = append(cmd, "--milestone", args.Milestone)
		}

		if args.State != "" {
			cmd = append(cmd, "--state", args.State)
		}

		if args.Search != "" {
			cmd = append(cmd, "--search", args.Search)
		}

		if args.App != "" {
			cmd = append(cmd, "--app", args.App)
		}

		if args.Limit > 0 {
			cmd = append(cmd, "--limit", fmt.Sprintf("%d", args.Limit))
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh issue list failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// IssueViewArgs defines parameters for gh issue view
type IssueViewArgs struct {
	Comments bool     `json:"comments,omitempty" jsonschema:"description=View issue comments"`
	Json     []string `json:"json,omitempty" jsonschema:"description=Output JSON with the specified fields"`
	Jq       string   `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Template string   `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`
	Web      bool     `json:"web,omitempty" jsonschema:"description=Open issue in the browser"`
	Repo     string   `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Issue number or URL (positional argument)"`
}

// RegisterIssueViewTool registers the gh issue view tool
func RegisterIssueViewTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_issue_view",
		Description: "View an issue",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args IssueViewArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"issue", "view"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Comments {
			cmd = append(cmd, "--comments")
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh issue view failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// IssueCloseArgs defines parameters for gh issue close
type IssueCloseArgs struct {
	Comment string `json:"comment,omitempty" jsonschema:"description=Leave a closing comment"`
	Reason  string `json:"reason,omitempty" jsonschema:"description=Reason for closing,enum=completed,enum=not planned"`
	Repo    string `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Issue number or URL (positional argument)"`
}

// RegisterIssueCloseTool registers the gh issue close tool
func RegisterIssueCloseTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_issue_close",
		Description: "Close an issue",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args IssueCloseArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"issue", "close"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Comment != "" {
			cmd = append(cmd, "--comment", args.Comment)
		}

		if args.Reason != "" {
			cmd = append(cmd, "--reason", args.Reason)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh issue close failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// IssueCommentArgs defines parameters for gh issue comment
type IssueCommentArgs struct {
	Body     string `json:"body,omitempty" jsonschema:"description=The comment body text"`
	BodyFile string `json:"body_file,omitempty" jsonschema:"description=Read body from file (use - for stdin)"`
	Editor   bool   `json:"editor,omitempty" jsonschema:"description=Skip prompts and open text editor for body"`
	Web      bool   `json:"web,omitempty" jsonschema:"description=Add comment in the web browser"`
	Repo     string `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Issue number or URL (positional argument)"`
}

// RegisterIssueCommentTool registers the gh issue comment tool
func RegisterIssueCommentTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_issue_comment",
		Description: "Add a comment to an issue",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args IssueCommentArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"issue", "comment"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Body != "" {
			cmd = append(cmd, "--body", args.Body)
		}

		if args.BodyFile != "" {
			cmd = append(cmd, "--body-file", args.BodyFile)
		}

		if args.Editor {
			cmd = append(cmd, "--editor")
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh issue comment failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// IssueDeleteArgs defines parameters for gh issue delete
type IssueDeleteArgs struct {
	Yes  bool   `json:"yes,omitempty" jsonschema:"description=Skip the confirmation prompt"`
	Repo string `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Issue number or URL (positional argument)"`
}

// RegisterIssueDeleteTool registers the gh issue delete tool
func RegisterIssueDeleteTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_issue_delete",
		Description: "Delete an issue",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args IssueDeleteArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"issue", "delete"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Yes {
			cmd = append(cmd, "--yes")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh issue delete failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// IssueEditArgs defines parameters for gh issue edit
type IssueEditArgs struct {
	Title          string   `json:"title,omitempty" jsonschema:"description=Set the new title"`
	Body           string   `json:"body,omitempty" jsonschema:"description=Set the new body"`
	BodyFile       string   `json:"body_file,omitempty" jsonschema:"description=Read body from file (use - for stdin)"`
	AddAssignee    []string `json:"add_assignee,omitempty" jsonschema:"description=Add assignees by their login"`
	RemoveAssignee []string `json:"remove_assignee,omitempty" jsonschema:"description=Remove assignees by their login"`
	AddLabel       []string `json:"add_label,omitempty" jsonschema:"description=Add labels by name"`
	RemoveLabel    []string `json:"remove_label,omitempty" jsonschema:"description=Remove labels by name"`
	AddProject     []string `json:"add_project,omitempty" jsonschema:"description=Add the issue to projects by title"`
	RemoveProject  []string `json:"remove_project,omitempty" jsonschema:"description=Remove the issue from projects by title"`
	Milestone      string   `json:"milestone,omitempty" jsonschema:"description=Edit the milestone (name or number)"`
	Repo           string   `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Issue number or URL (positional argument)"`
}

// RegisterIssueEditTool registers the gh issue edit tool
func RegisterIssueEditTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_issue_edit",
		Description: "Edit an issue",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args IssueEditArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"issue", "edit"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Title != "" {
			cmd = append(cmd, "--title", args.Title)
		}

		if args.Body != "" {
			cmd = append(cmd, "--body", args.Body)
		}

		if args.BodyFile != "" {
			cmd = append(cmd, "--body-file", args.BodyFile)
		}

		for _, v := range args.AddAssignee {
			cmd = append(cmd, "--add-assignee", v)
		}

		for _, v := range args.RemoveAssignee {
			cmd = append(cmd, "--remove-assignee", v)
		}

		for _, v := range args.AddLabel {
			cmd = append(cmd, "--add-label", v)
		}

		for _, v := range args.RemoveLabel {
			cmd = append(cmd, "--remove-label", v)
		}

		for _, v := range args.AddProject {
			cmd = append(cmd, "--add-project", v)
		}

		for _, v := range args.RemoveProject {
			cmd = append(cmd, "--remove-project", v)
		}

		if args.Milestone != "" {
			cmd = append(cmd, "--milestone", args.Milestone)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh issue edit failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// IssueLockArgs defines parameters for gh issue lock
type IssueLockArgs struct {
	Reason string `json:"reason,omitempty" jsonschema:"description=Reason for locking,enum=off-topic,enum=spam,enum=resolved,enum=too heated"`
	Repo   string `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Issue number or URL (positional argument)"`
}

// RegisterIssueLockTool registers the gh issue lock tool
func RegisterIssueLockTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_issue_lock",
		Description: "Lock issue conversation",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args IssueLockArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"issue", "lock"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Reason != "" {
			cmd = append(cmd, "--reason", args.Reason)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh issue lock failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// IssuePinArgs defines parameters for gh issue pin
type IssuePinArgs struct {
	Repo string `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Issue number or URL (positional argument)"`
}

// RegisterIssuePinTool registers the gh issue pin tool
func RegisterIssuePinTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_issue_pin",
		Description: "Pin an issue to a repository",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args IssuePinArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"issue", "pin"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh issue pin failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// IssueReopenArgs defines parameters for gh issue reopen
type IssueReopenArgs struct {
	Comment string `json:"comment,omitempty" jsonschema:"description=Add a reopening comment"`
	Repo    string `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Issue number or URL (positional argument)"`
}

// RegisterIssueReopenTool registers the gh issue reopen tool
func RegisterIssueReopenTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_issue_reopen",
		Description: "Reopen a closed issue",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args IssueReopenArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"issue", "reopen"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Comment != "" {
			cmd = append(cmd, "--comment", args.Comment)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh issue reopen failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// IssueStatusArgs defines parameters for gh issue status
type IssueStatusArgs struct {
	Jq       string   `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Json     []string `json:"json,omitempty" jsonschema:"description=Output JSON with the specified fields"`
	Template string   `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`
	Repo     string   `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`
}

// RegisterIssueStatusTool registers the gh issue status tool
func RegisterIssueStatusTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_issue_status",
		Description: "Show status of relevant issues",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args IssueStatusArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"issue", "status"}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh issue status failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// IssueTransferArgs defines parameters for gh issue transfer
type IssueTransferArgs struct {
	Repo string `json:"repo,omitempty" jsonschema:"description=Select source repository in OWNER/REPO format"`

	Number      string `json:"number,omitempty" jsonschema:"description=Issue number or URL (positional argument)"`
	Destination string `json:"destination,omitempty" jsonschema:"description=Destination repository in OWNER/REPO format (positional argument)"`
}

// RegisterIssueTransferTool registers the gh issue transfer tool
func RegisterIssueTransferTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_issue_transfer",
		Description: "Transfer issue to another repository",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args IssueTransferArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"issue", "transfer"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		// Add positional argument: destination
		if args.Destination != "" {
			cmd = append(cmd, args.Destination)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh issue transfer failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// IssueUnlockArgs defines parameters for gh issue unlock
type IssueUnlockArgs struct {
	Repo string `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Issue number or URL (positional argument)"`
}

// RegisterIssueUnlockTool registers the gh issue unlock tool
func RegisterIssueUnlockTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_issue_unlock",
		Description: "Unlock issue conversation",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args IssueUnlockArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"issue", "unlock"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh issue unlock failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// IssueUnpinArgs defines parameters for gh issue unpin
type IssueUnpinArgs struct {
	Repo string `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Issue number or URL (positional argument)"`
}

// RegisterIssueUnpinTool registers the gh issue unpin tool
func RegisterIssueUnpinTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_issue_unpin",
		Description: "Unpin an issue from a repository",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args IssueUnpinArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"issue", "unpin"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh issue unpin failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
