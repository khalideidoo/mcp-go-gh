// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalid/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// LabelCreateArgs defines parameters for gh label create
type LabelCreateArgs struct {
	Color       string `json:"color,omitempty" jsonschema:"description=Color of the label (6 character hex value)"`
	Description string `json:"description,omitempty" jsonschema:"description=Description of the label"`
	Force       bool   `json:"force,omitempty" jsonschema:"description=Update the label color and description if label already exists"`
	Repo        string `json:"repo,omitempty" jsonschema:"description=Select repository in OWNER/REPO format"`

	Name string `json:"name,omitempty" jsonschema:"description=Name of the label (positional),required"`
}

// RegisterLabelCreateTool registers the gh label create tool
func RegisterLabelCreateTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_label_create",
		Description: "Create a new label",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args LabelCreateArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"label", "create"}

		// Add positional argument: name
		if args.Name != "" {
			cmd = append(cmd, args.Name)
		}

		if args.Color != "" {
			cmd = append(cmd, "--color", args.Color)
		}

		if args.Description != "" {
			cmd = append(cmd, "--description", args.Description)
		}

		if args.Force {
			cmd = append(cmd, "--force")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh label create failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// LabelListArgs defines parameters for gh label list
type LabelListArgs struct {
	Limit    int      `json:"limit,omitempty" jsonschema:"description=Maximum number of labels to fetch"`
	Json     []string `json:"json,omitempty" jsonschema:"description=Output JSON with the specified fields"`
	Jq       string   `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Template string   `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`
	Web      bool     `json:"web,omitempty" jsonschema:"description=Open labels in the web browser"`
	Repo     string   `json:"repo,omitempty" jsonschema:"description=Select repository in OWNER/REPO format"`
}

// RegisterLabelListTool registers the gh label list tool
func RegisterLabelListTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_label_list",
		Description: "List labels in a repository",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args LabelListArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"label", "list"}

		if args.Limit > 0 {
			cmd = append(cmd, "--limit", fmt.Sprintf("%d", args.Limit))
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh label list failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// LabelEditArgs defines parameters for gh label edit
type LabelEditArgs struct {
	Color       string `json:"color,omitempty" jsonschema:"description=Color of the label (6 character hex value)"`
	Description string `json:"description,omitempty" jsonschema:"description=Description of the label"`
	NewName     string `json:"new_name,omitempty" jsonschema:"description=New name of the label"`
	Repo        string `json:"repo,omitempty" jsonschema:"description=Select repository in OWNER/REPO format"`

	Name string `json:"name,omitempty" jsonschema:"description=Current name of the label (positional),required"`
}

// RegisterLabelEditTool registers the gh label edit tool
func RegisterLabelEditTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_label_edit",
		Description: "Edit a label",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args LabelEditArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"label", "edit"}

		// Add positional argument: name
		if args.Name != "" {
			cmd = append(cmd, args.Name)
		}

		if args.Color != "" {
			cmd = append(cmd, "--color", args.Color)
		}

		if args.Description != "" {
			cmd = append(cmd, "--description", args.Description)
		}

		if args.NewName != "" {
			cmd = append(cmd, "--name", args.NewName)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh label edit failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// LabelDeleteArgs defines parameters for gh label delete
type LabelDeleteArgs struct {
	Yes  bool   `json:"yes,omitempty" jsonschema:"description=Skip the confirmation prompt"`
	Repo string `json:"repo,omitempty" jsonschema:"description=Select repository in OWNER/REPO format"`

	Name string `json:"name,omitempty" jsonschema:"description=Name of the label (positional),required"`
}

// RegisterLabelDeleteTool registers the gh label delete tool
func RegisterLabelDeleteTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_label_delete",
		Description: "Delete a label from a repository",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args LabelDeleteArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"label", "delete"}

		// Add positional argument: name
		if args.Name != "" {
			cmd = append(cmd, args.Name)
		}

		if args.Yes {
			cmd = append(cmd, "--yes")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh label delete failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// LabelCloneArgs defines parameters for gh label clone
type LabelCloneArgs struct {
	Force bool   `json:"force,omitempty" jsonschema:"description=Overwrite labels in the destination repository"`
	Repo  string `json:"repo,omitempty" jsonschema:"description=Destination repository in OWNER/REPO format"`

	SourceRepository string `json:"source_repository,omitempty" jsonschema:"description=Source repository in OWNER/REPO format (positional),required"`
}

// RegisterLabelCloneTool registers the gh label clone tool
func RegisterLabelCloneTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_label_clone",
		Description: "Clone labels from one repository to another",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args LabelCloneArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"label", "clone"}

		// Add positional argument: source_repository
		if args.SourceRepository != "" {
			cmd = append(cmd, args.SourceRepository)
		}

		if args.Force {
			cmd = append(cmd, "--force")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh label clone failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
