// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalid/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// PrCreateArgs defines parameters for gh pr create
type PrCreateArgs struct {
	Title            string   `json:"title,omitempty" jsonschema:"description=Title for the pull request"`
	Body             string   `json:"body,omitempty" jsonschema:"description=Body text for the pull request"`
	BodyFile         string   `json:"body_file,omitempty" jsonschema:"description=Read body text from file (use - for stdin)"`
	Fill             bool     `json:"fill,omitempty" jsonschema:"description=Use commit info for title and body"`
	FillFirst        bool     `json:"fill_first,omitempty" jsonschema:"description=Use first commit for title and body"`
	FillVerbose      bool     `json:"fill_verbose,omitempty" jsonschema:"description=Use commits msg+body for description"`
	Base             string   `json:"base,omitempty" jsonschema:"description=The base branch to merge into"`
	Head             string   `json:"head,omitempty" jsonschema:"description=The head branch containing commits"`
	Draft            bool     `json:"draft,omitempty" jsonschema:"description=Mark pull request as a draft"`
	NoMaintainerEdit bool     `json:"no_maintainer_edit,omitempty" jsonschema:"description=Disable maintainer ability to modify PR"`
	Assignee         []string `json:"assignee,omitempty" jsonschema:"description=Assign people by their login (use @me for self)"`
	Reviewer         []string `json:"reviewer,omitempty" jsonschema:"description=Request reviews from people or teams"`
	Label            []string `json:"label,omitempty" jsonschema:"description=Add labels by name"`
	Milestone        string   `json:"milestone,omitempty" jsonschema:"description=Add the pull request to a milestone by name"`
	Project          []string `json:"project,omitempty" jsonschema:"description=Add the pull request to projects by title"`
	Template         string   `json:"template,omitempty" jsonschema:"description=Template file to use as starting body text"`
	Recover          string   `json:"recover,omitempty" jsonschema:"description=Recover input from a failed run"`
	Web              bool     `json:"web,omitempty" jsonschema:"description=Open the web browser to create a pull request"`
	DryRun           bool     `json:"dry_run,omitempty" jsonschema:"description=Print details instead of creating the PR"`
	Repo             string   `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`
}

// RegisterPrCreateTool registers the gh pr create tool
func RegisterPrCreateTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_pr_create",
		Description: "Create a pull request on GitHub",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args PrCreateArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"pr", "create"}

		if args.Title != "" {
			cmd = append(cmd, "--title", args.Title)
		}

		if args.Body != "" {
			cmd = append(cmd, "--body", args.Body)
		}

		if args.BodyFile != "" {
			cmd = append(cmd, "--body-file", args.BodyFile)
		}

		if args.Fill {
			cmd = append(cmd, "--fill")
		}

		if args.FillFirst {
			cmd = append(cmd, "--fill-first")
		}

		if args.FillVerbose {
			cmd = append(cmd, "--fill-verbose")
		}

		if args.Base != "" {
			cmd = append(cmd, "--base", args.Base)
		}

		if args.Head != "" {
			cmd = append(cmd, "--head", args.Head)
		}

		if args.Draft {
			cmd = append(cmd, "--draft")
		}

		if args.NoMaintainerEdit {
			cmd = append(cmd, "--no-maintainer-edit")
		}

		for _, v := range args.Assignee {
			cmd = append(cmd, "--assignee", v)
		}

		for _, v := range args.Reviewer {
			cmd = append(cmd, "--reviewer", v)
		}

		for _, v := range args.Label {
			cmd = append(cmd, "--label", v)
		}

		if args.Milestone != "" {
			cmd = append(cmd, "--milestone", args.Milestone)
		}

		for _, v := range args.Project {
			cmd = append(cmd, "--project", v)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Recover != "" {
			cmd = append(cmd, "--recover", args.Recover)
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		if args.DryRun {
			cmd = append(cmd, "--dry-run")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh pr create failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// PrListArgs defines parameters for gh pr list
type PrListArgs struct {
	Assignee string   `json:"assignee,omitempty" jsonschema:"description=Filter by assignee"`
	Author   string   `json:"author,omitempty" jsonschema:"description=Filter by author"`
	Base     string   `json:"base,omitempty" jsonschema:"description=Filter by base branch"`
	Head     string   `json:"head,omitempty" jsonschema:"description=Filter by head branch"`
	Label    []string `json:"label,omitempty" jsonschema:"description=Filter by label"`
	State    string   `json:"state,omitempty" jsonschema:"description=Filter by state,enum=open,enum=closed,enum=merged,enum=all"`
	Search   string   `json:"search,omitempty" jsonschema:"description=Search pull requests with query"`
	App      string   `json:"app,omitempty" jsonschema:"description=Filter by GitHub App author"`
	Draft    bool     `json:"draft,omitempty" jsonschema:"description=Filter by draft state"`
	Limit    int      `json:"limit,omitempty" jsonschema:"description=Maximum number of items to fetch"`
	Json     []string `json:"json,omitempty" jsonschema:"description=Output JSON with the specified fields"`
	Jq       string   `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Template string   `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`
	Web      bool     `json:"web,omitempty" jsonschema:"description=List pull requests in the web browser"`
	Repo     string   `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`
}

// RegisterPrListTool registers the gh pr list tool
func RegisterPrListTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_pr_list",
		Description: "List pull requests in a repository",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args PrListArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"pr", "list"}

		if args.Assignee != "" {
			cmd = append(cmd, "--assignee", args.Assignee)
		}

		if args.Author != "" {
			cmd = append(cmd, "--author", args.Author)
		}

		if args.Base != "" {
			cmd = append(cmd, "--base", args.Base)
		}

		if args.Head != "" {
			cmd = append(cmd, "--head", args.Head)
		}

		for _, v := range args.Label {
			cmd = append(cmd, "--label", v)
		}

		if args.State != "" {
			cmd = append(cmd, "--state", args.State)
		}

		if args.Search != "" {
			cmd = append(cmd, "--search", args.Search)
		}

		if args.App != "" {
			cmd = append(cmd, "--app", args.App)
		}

		if args.Draft {
			cmd = append(cmd, "--draft")
		}

		if args.Limit > 0 {
			cmd = append(cmd, "--limit", fmt.Sprintf("%d", args.Limit))
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh pr list failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// PrViewArgs defines parameters for gh pr view
type PrViewArgs struct {
	Comments bool     `json:"comments,omitempty" jsonschema:"description=View pull request comments"`
	Json     []string `json:"json,omitempty" jsonschema:"description=Output JSON with the specified fields"`
	Jq       string   `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Template string   `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`
	Web      bool     `json:"web,omitempty" jsonschema:"description=Open pull request in the browser"`
	Repo     string   `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Pull request number or URL (positional argument)"`
}

// RegisterPrViewTool registers the gh pr view tool
func RegisterPrViewTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_pr_view",
		Description: "View a pull request",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args PrViewArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"pr", "view"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Comments {
			cmd = append(cmd, "--comments")
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh pr view failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// PrCloseArgs defines parameters for gh pr close
type PrCloseArgs struct {
	Comment      string `json:"comment,omitempty" jsonschema:"description=Leave a closing comment"`
	DeleteBranch bool   `json:"delete_branch,omitempty" jsonschema:"description=Delete the local and remote branch after close"`
	Repo         string `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Pull request number or URL (positional argument)"`
}

// RegisterPrCloseTool registers the gh pr close tool
func RegisterPrCloseTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_pr_close",
		Description: "Close a pull request",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args PrCloseArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"pr", "close"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Comment != "" {
			cmd = append(cmd, "--comment", args.Comment)
		}

		if args.DeleteBranch {
			cmd = append(cmd, "--delete-branch")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh pr close failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// PrMergeArgs defines parameters for gh pr merge
type PrMergeArgs struct {
	Admin           bool   `json:"admin,omitempty" jsonschema:"description=Use administrator privileges to merge"`
	Auto            bool   `json:"auto,omitempty" jsonschema:"description=Automatically merge when requirements are met"`
	Body            string `json:"body,omitempty" jsonschema:"description=Body text for the merge commit"`
	BodyFile        string `json:"body_file,omitempty" jsonschema:"description=Read body from file (use - for stdin)"`
	DeleteBranch    bool   `json:"delete_branch,omitempty" jsonschema:"description=Delete the local and remote branch after merge"`
	DisableAuto     bool   `json:"disable_auto,omitempty" jsonschema:"description=Disable auto-merge for pull request"`
	Merge           bool   `json:"merge,omitempty" jsonschema:"description=Merge the commits with merge commit"`
	Rebase          bool   `json:"rebase,omitempty" jsonschema:"description=Rebase the commits onto the base branch"`
	Squash          bool   `json:"squash,omitempty" jsonschema:"description=Squash the commits into one commit"`
	Subject         string `json:"subject,omitempty" jsonschema:"description=Subject for the merge commit"`
	MatchHeadCommit string `json:"match_head_commit,omitempty" jsonschema:"description=Commit SHA the PR head must match"`
	Repo            string `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Pull request number or URL (positional argument)"`
}

// RegisterPrMergeTool registers the gh pr merge tool
func RegisterPrMergeTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_pr_merge",
		Description: "Merge a pull request",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args PrMergeArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"pr", "merge"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Admin {
			cmd = append(cmd, "--admin")
		}

		if args.Auto {
			cmd = append(cmd, "--auto")
		}

		if args.Body != "" {
			cmd = append(cmd, "--body", args.Body)
		}

		if args.BodyFile != "" {
			cmd = append(cmd, "--body-file", args.BodyFile)
		}

		if args.DeleteBranch {
			cmd = append(cmd, "--delete-branch")
		}

		if args.DisableAuto {
			cmd = append(cmd, "--disable-auto")
		}

		if args.Merge {
			cmd = append(cmd, "--merge")
		}

		if args.Rebase {
			cmd = append(cmd, "--rebase")
		}

		if args.Squash {
			cmd = append(cmd, "--squash")
		}

		if args.Subject != "" {
			cmd = append(cmd, "--subject", args.Subject)
		}

		if args.MatchHeadCommit != "" {
			cmd = append(cmd, "--match-head-commit", args.MatchHeadCommit)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh pr merge failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// PrCheckoutArgs defines parameters for gh pr checkout
type PrCheckoutArgs struct {
	Branch            string `json:"branch,omitempty" jsonschema:"description=Local branch name to use"`
	Detach            bool   `json:"detach,omitempty" jsonschema:"description=Checkout PR with a detached HEAD"`
	Force             bool   `json:"force,omitempty" jsonschema:"description=Reset the existing local branch to the latest state"`
	RecurseSubmodules bool   `json:"recurse_submodules,omitempty" jsonschema:"description=Update all submodules after checkout"`
	Repo              string `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Pull request number or URL or branch (positional argument)"`
}

// RegisterPrCheckoutTool registers the gh pr checkout tool
func RegisterPrCheckoutTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_pr_checkout",
		Description: "Check out a pull request in git",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args PrCheckoutArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"pr", "checkout"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Branch != "" {
			cmd = append(cmd, "--branch", args.Branch)
		}

		if args.Detach {
			cmd = append(cmd, "--detach")
		}

		if args.Force {
			cmd = append(cmd, "--force")
		}

		if args.RecurseSubmodules {
			cmd = append(cmd, "--recurse-submodules")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh pr checkout failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// PrChecksArgs defines parameters for gh pr checks
type PrChecksArgs struct {
	FailFast bool   `json:"fail_fast,omitempty" jsonschema:"description=Exit watch mode on first failure"`
	Interval int    `json:"interval,omitempty" jsonschema:"description=Refresh interval in seconds for watch mode"`
	Watch    bool   `json:"watch,omitempty" jsonschema:"description=Watch checks until they finish"`
	Web      bool   `json:"web,omitempty" jsonschema:"description=Open the web browser to show checks"`
	Repo     string `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Pull request number or URL (positional argument)"`
}

// RegisterPrChecksTool registers the gh pr checks tool
func RegisterPrChecksTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_pr_checks",
		Description: "Show CI status for a pull request",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args PrChecksArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"pr", "checks"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.FailFast {
			cmd = append(cmd, "--fail-fast")
		}

		if args.Interval > 0 {
			cmd = append(cmd, "--interval", fmt.Sprintf("%d", args.Interval))
		}

		if args.Watch {
			cmd = append(cmd, "--watch")
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh pr checks failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// PrDiffArgs defines parameters for gh pr diff
type PrDiffArgs struct {
	Color    string `json:"color,omitempty" jsonschema:"description=Use colored output,enum=always,enum=never,enum=auto"`
	NameOnly bool   `json:"name_only,omitempty" jsonschema:"description=Display only names of changed files"`
	Patch    bool   `json:"patch,omitempty" jsonschema:"description=Display diff in patch format"`
	Web      bool   `json:"web,omitempty" jsonschema:"description=Open the pull request diff in the browser"`
	Repo     string `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Pull request number or URL (positional argument)"`
}

// RegisterPrDiffTool registers the gh pr diff tool
func RegisterPrDiffTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_pr_diff",
		Description: "View changes in a pull request",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args PrDiffArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"pr", "diff"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Color != "" {
			cmd = append(cmd, "--color", args.Color)
		}

		if args.NameOnly {
			cmd = append(cmd, "--name-only")
		}

		if args.Patch {
			cmd = append(cmd, "--patch")
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh pr diff failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// PrCommentArgs defines parameters for gh pr comment
type PrCommentArgs struct {
	Body     string `json:"body,omitempty" jsonschema:"description=The comment body text"`
	BodyFile string `json:"body_file,omitempty" jsonschema:"description=Read body from file (use - for stdin)"`
	Editor   bool   `json:"editor,omitempty" jsonschema:"description=Skip prompts and open text editor for body"`
	Web      bool   `json:"web,omitempty" jsonschema:"description=Add comment in the web browser"`
	Repo     string `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Pull request number or URL (positional argument)"`
}

// RegisterPrCommentTool registers the gh pr comment tool
func RegisterPrCommentTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_pr_comment",
		Description: "Add a comment to a pull request",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args PrCommentArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"pr", "comment"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Body != "" {
			cmd = append(cmd, "--body", args.Body)
		}

		if args.BodyFile != "" {
			cmd = append(cmd, "--body-file", args.BodyFile)
		}

		if args.Editor {
			cmd = append(cmd, "--editor")
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh pr comment failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// PrEditArgs defines parameters for gh pr edit
type PrEditArgs struct {
	Title          string   `json:"title,omitempty" jsonschema:"description=Set the new title"`
	Body           string   `json:"body,omitempty" jsonschema:"description=Set the new body"`
	BodyFile       string   `json:"body_file,omitempty" jsonschema:"description=Read body from file (use - for stdin)"`
	AddAssignee    []string `json:"add_assignee,omitempty" jsonschema:"description=Add assignees by their login"`
	RemoveAssignee []string `json:"remove_assignee,omitempty" jsonschema:"description=Remove assignees by their login"`
	AddLabel       []string `json:"add_label,omitempty" jsonschema:"description=Add labels by name"`
	RemoveLabel    []string `json:"remove_label,omitempty" jsonschema:"description=Remove labels by name"`
	AddProject     []string `json:"add_project,omitempty" jsonschema:"description=Add the pull request to projects by title"`
	RemoveProject  []string `json:"remove_project,omitempty" jsonschema:"description=Remove the pull request from projects by title"`
	AddReviewer    []string `json:"add_reviewer,omitempty" jsonschema:"description=Add reviewers by their login"`
	RemoveReviewer []string `json:"remove_reviewer,omitempty" jsonschema:"description=Remove reviewers by their login"`
	Milestone      string   `json:"milestone,omitempty" jsonschema:"description=Edit the milestone (name or number)"`
	Base           string   `json:"base,omitempty" jsonschema:"description=Change the base branch"`
	Repo           string   `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Pull request number or URL (positional argument)"`
}

// RegisterPrEditTool registers the gh pr edit tool
func RegisterPrEditTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_pr_edit",
		Description: "Edit a pull request",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args PrEditArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"pr", "edit"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Title != "" {
			cmd = append(cmd, "--title", args.Title)
		}

		if args.Body != "" {
			cmd = append(cmd, "--body", args.Body)
		}

		if args.BodyFile != "" {
			cmd = append(cmd, "--body-file", args.BodyFile)
		}

		for _, v := range args.AddAssignee {
			cmd = append(cmd, "--add-assignee", v)
		}

		for _, v := range args.RemoveAssignee {
			cmd = append(cmd, "--remove-assignee", v)
		}

		for _, v := range args.AddLabel {
			cmd = append(cmd, "--add-label", v)
		}

		for _, v := range args.RemoveLabel {
			cmd = append(cmd, "--remove-label", v)
		}

		for _, v := range args.AddProject {
			cmd = append(cmd, "--add-project", v)
		}

		for _, v := range args.RemoveProject {
			cmd = append(cmd, "--remove-project", v)
		}

		for _, v := range args.AddReviewer {
			cmd = append(cmd, "--add-reviewer", v)
		}

		for _, v := range args.RemoveReviewer {
			cmd = append(cmd, "--remove-reviewer", v)
		}

		if args.Milestone != "" {
			cmd = append(cmd, "--milestone", args.Milestone)
		}

		if args.Base != "" {
			cmd = append(cmd, "--base", args.Base)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh pr edit failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// PrReadyArgs defines parameters for gh pr ready
type PrReadyArgs struct {
	Undo bool   `json:"undo,omitempty" jsonschema:"description=Convert a ready pull request to draft"`
	Repo string `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Pull request number or URL (positional argument)"`
}

// RegisterPrReadyTool registers the gh pr ready tool
func RegisterPrReadyTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_pr_ready",
		Description: "Mark a pull request as ready for review",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args PrReadyArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"pr", "ready"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Undo {
			cmd = append(cmd, "--undo")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh pr ready failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// PrReopenArgs defines parameters for gh pr reopen
type PrReopenArgs struct {
	Comment string `json:"comment,omitempty" jsonschema:"description=Add a reopening comment"`
	Repo    string `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Pull request number or URL (positional argument)"`
}

// RegisterPrReopenTool registers the gh pr reopen tool
func RegisterPrReopenTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_pr_reopen",
		Description: "Reopen a closed pull request",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args PrReopenArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"pr", "reopen"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Comment != "" {
			cmd = append(cmd, "--comment", args.Comment)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh pr reopen failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// PrReviewArgs defines parameters for gh pr review
type PrReviewArgs struct {
	Approve        bool   `json:"approve,omitempty" jsonschema:"description=Approve pull request"`
	Comment        bool   `json:"comment,omitempty" jsonschema:"description=Comment on pull request"`
	RequestChanges bool   `json:"request_changes,omitempty" jsonschema:"description=Request changes on pull request"`
	Body           string `json:"body,omitempty" jsonschema:"description=Specify the body of a review"`
	BodyFile       string `json:"body_file,omitempty" jsonschema:"description=Read body from file (use - for stdin)"`
	Repo           string `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`

	Number string `json:"number,omitempty" jsonschema:"description=Pull request number or URL (positional argument)"`
}

// RegisterPrReviewTool registers the gh pr review tool
func RegisterPrReviewTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_pr_review",
		Description: "Add a review to a pull request",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args PrReviewArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"pr", "review"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Approve {
			cmd = append(cmd, "--approve")
		}

		if args.Comment {
			cmd = append(cmd, "--comment")
		}

		if args.RequestChanges {
			cmd = append(cmd, "--request-changes")
		}

		if args.Body != "" {
			cmd = append(cmd, "--body", args.Body)
		}

		if args.BodyFile != "" {
			cmd = append(cmd, "--body-file", args.BodyFile)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh pr review failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// PrStatusArgs defines parameters for gh pr status
type PrStatusArgs struct {
	Jq       string   `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Json     []string `json:"json,omitempty" jsonschema:"description=Output JSON with the specified fields"`
	Template string   `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`
	Repo     string   `json:"repo,omitempty" jsonschema:"description=Select target repository in OWNER/REPO format"`
}

// RegisterPrStatusTool registers the gh pr status tool
func RegisterPrStatusTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_pr_status",
		Description: "Show status of relevant pull requests",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args PrStatusArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"pr", "status"}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh pr status failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
