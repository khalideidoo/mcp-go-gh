// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalid/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// ProjectCreateArgs defines parameters for gh project create
type ProjectCreateArgs struct {
	Owner    string `json:"owner,omitempty" jsonschema:"description=Login of the owner (use @me for current user),required"`
	Title    string `json:"title,omitempty" jsonschema:"description=Title for the project,required"`
	Format   string `json:"format,omitempty" jsonschema:"description=Output format,enum=json"`
	Jq       string `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Template string `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`
}

// RegisterProjectCreateTool registers the gh project create tool
func RegisterProjectCreateTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_project_create",
		Description: "Create a project",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ProjectCreateArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"project", "create"}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.Title != "" {
			cmd = append(cmd, "--title", args.Title)
		}

		if args.Format != "" {
			cmd = append(cmd, "--format", args.Format)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh project create failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ProjectListArgs defines parameters for gh project list
type ProjectListArgs struct {
	Owner    string `json:"owner,omitempty" jsonschema:"description=Login of the owner (use @me for current user),required"`
	Closed   bool   `json:"closed,omitempty" jsonschema:"description=Include closed projects"`
	Limit    int    `json:"limit,omitempty" jsonschema:"description=Maximum number of projects to fetch"`
	Format   string `json:"format,omitempty" jsonschema:"description=Output format,enum=json"`
	Jq       string `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Template string `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`
	Web      bool   `json:"web,omitempty" jsonschema:"description=Open projects list in the browser"`
}

// RegisterProjectListTool registers the gh project list tool
func RegisterProjectListTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_project_list",
		Description: "List the projects for an owner",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ProjectListArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"project", "list"}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.Closed {
			cmd = append(cmd, "--closed")
		}

		if args.Limit > 0 {
			cmd = append(cmd, "--limit", fmt.Sprintf("%d", args.Limit))
		}

		if args.Format != "" {
			cmd = append(cmd, "--format", args.Format)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh project list failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ProjectViewArgs defines parameters for gh project view
type ProjectViewArgs struct {
	Owner    string `json:"owner,omitempty" jsonschema:"description=Login of the owner (use @me for current user),required"`
	Format   string `json:"format,omitempty" jsonschema:"description=Output format,enum=json"`
	Jq       string `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Template string `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`
	Web      bool   `json:"web,omitempty" jsonschema:"description=Open project in the browser"`

	Number string `json:"number,omitempty" jsonschema:"description=Project number (positional),required"`
}

// RegisterProjectViewTool registers the gh project view tool
func RegisterProjectViewTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_project_view",
		Description: "View a project",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ProjectViewArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"project", "view"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.Format != "" {
			cmd = append(cmd, "--format", args.Format)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh project view failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ProjectEditArgs defines parameters for gh project edit
type ProjectEditArgs struct {
	Owner       string `json:"owner,omitempty" jsonschema:"description=Login of the owner (use @me for current user),required"`
	Title       string `json:"title,omitempty" jsonschema:"description=New title for the project"`
	Description string `json:"description,omitempty" jsonschema:"description=New description for the project"`
	Readme      string `json:"readme,omitempty" jsonschema:"description=New README for the project"`
	Visibility  string `json:"visibility,omitempty" jsonschema:"description=Change project visibility,enum=PUBLIC,enum=PRIVATE"`
	Format      string `json:"format,omitempty" jsonschema:"description=Output format,enum=json"`
	Jq          string `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Template    string `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`

	Number string `json:"number,omitempty" jsonschema:"description=Project number (positional),required"`
}

// RegisterProjectEditTool registers the gh project edit tool
func RegisterProjectEditTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_project_edit",
		Description: "Edit a project",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ProjectEditArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"project", "edit"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.Title != "" {
			cmd = append(cmd, "--title", args.Title)
		}

		if args.Description != "" {
			cmd = append(cmd, "--description", args.Description)
		}

		if args.Readme != "" {
			cmd = append(cmd, "--readme", args.Readme)
		}

		if args.Visibility != "" {
			cmd = append(cmd, "--visibility", args.Visibility)
		}

		if args.Format != "" {
			cmd = append(cmd, "--format", args.Format)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh project edit failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ProjectCloseArgs defines parameters for gh project close
type ProjectCloseArgs struct {
	Owner  string `json:"owner,omitempty" jsonschema:"description=Login of the owner (use @me for current user),required"`
	Undo   bool   `json:"undo,omitempty" jsonschema:"description=Reopen a closed project"`
	Format string `json:"format,omitempty" jsonschema:"description=Output format,enum=json"`

	Number string `json:"number,omitempty" jsonschema:"description=Project number (positional),required"`
}

// RegisterProjectCloseTool registers the gh project close tool
func RegisterProjectCloseTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_project_close",
		Description: "Close a project",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ProjectCloseArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"project", "close"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.Undo {
			cmd = append(cmd, "--undo")
		}

		if args.Format != "" {
			cmd = append(cmd, "--format", args.Format)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh project close failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ProjectDeleteArgs defines parameters for gh project delete
type ProjectDeleteArgs struct {
	Owner  string `json:"owner,omitempty" jsonschema:"description=Login of the owner (use @me for current user),required"`
	Format string `json:"format,omitempty" jsonschema:"description=Output format,enum=json"`

	Number string `json:"number,omitempty" jsonschema:"description=Project number (positional),required"`
}

// RegisterProjectDeleteTool registers the gh project delete tool
func RegisterProjectDeleteTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_project_delete",
		Description: "Delete a project",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ProjectDeleteArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"project", "delete"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.Format != "" {
			cmd = append(cmd, "--format", args.Format)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh project delete failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ProjectCopyArgs defines parameters for gh project copy
type ProjectCopyArgs struct {
	SourceOwner string `json:"source_owner,omitempty" jsonschema:"description=Login of the source owner,required"`
	TargetOwner string `json:"target_owner,omitempty" jsonschema:"description=Login of the target owner,required"`
	Title       string `json:"title,omitempty" jsonschema:"description=Title for the new project"`
	Drafts      bool   `json:"drafts,omitempty" jsonschema:"description=Include draft issues when copying"`
	Format      string `json:"format,omitempty" jsonschema:"description=Output format,enum=json"`

	Number string `json:"number,omitempty" jsonschema:"description=Project number to copy (positional),required"`
}

// RegisterProjectCopyTool registers the gh project copy tool
func RegisterProjectCopyTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_project_copy",
		Description: "Copy a project",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ProjectCopyArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"project", "copy"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.SourceOwner != "" {
			cmd = append(cmd, "--source-owner", args.SourceOwner)
		}

		if args.TargetOwner != "" {
			cmd = append(cmd, "--target-owner", args.TargetOwner)
		}

		if args.Title != "" {
			cmd = append(cmd, "--title", args.Title)
		}

		if args.Drafts {
			cmd = append(cmd, "--drafts")
		}

		if args.Format != "" {
			cmd = append(cmd, "--format", args.Format)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh project copy failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ProjectFieldListArgs defines parameters for gh project field-list
type ProjectFieldListArgs struct {
	Owner    string `json:"owner,omitempty" jsonschema:"description=Login of the owner (use @me for current user),required"`
	Limit    int    `json:"limit,omitempty" jsonschema:"description=Maximum number of fields to fetch"`
	Format   string `json:"format,omitempty" jsonschema:"description=Output format,enum=json"`
	Jq       string `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Template string `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`

	Number string `json:"number,omitempty" jsonschema:"description=Project number (positional),required"`
}

// RegisterProjectFieldListTool registers the gh project field-list tool
func RegisterProjectFieldListTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_project_field_list",
		Description: "List the fields in a project",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ProjectFieldListArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"project", "field-list"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.Limit > 0 {
			cmd = append(cmd, "--limit", fmt.Sprintf("%d", args.Limit))
		}

		if args.Format != "" {
			cmd = append(cmd, "--format", args.Format)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh project field-list failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ProjectFieldCreateArgs defines parameters for gh project field-create
type ProjectFieldCreateArgs struct {
	Owner    string `json:"owner,omitempty" jsonschema:"description=Login of the owner (use @me for current user),required"`
	Name     string `json:"name,omitempty" jsonschema:"description=Name of the field,required"`
	DataType string `json:"data_type,omitempty" jsonschema:"description=DataType of the field,required,enum=TEXT,enum=NUMBER,enum=DATE,enum=SINGLE_SELECT,enum=ITERATION"`
	Format   string `json:"format,omitempty" jsonschema:"description=Output format,enum=json"`

	Number string `json:"number,omitempty" jsonschema:"description=Project number (positional),required"`
}

// RegisterProjectFieldCreateTool registers the gh project field-create tool
func RegisterProjectFieldCreateTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_project_field_create",
		Description: "Create a field in a project",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ProjectFieldCreateArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"project", "field-create"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.Name != "" {
			cmd = append(cmd, "--name", args.Name)
		}

		if args.DataType != "" {
			cmd = append(cmd, "--data-type", args.DataType)
		}

		if args.Format != "" {
			cmd = append(cmd, "--format", args.Format)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh project field-create failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ProjectFieldDeleteArgs defines parameters for gh project field-delete
type ProjectFieldDeleteArgs struct {
	Owner  string `json:"owner,omitempty" jsonschema:"description=Login of the owner (use @me for current user),required"`
	Id     string `json:"id,omitempty" jsonschema:"description=ID of the field to delete,required"`
	Format string `json:"format,omitempty" jsonschema:"description=Output format,enum=json"`

	Number string `json:"number,omitempty" jsonschema:"description=Project number (positional),required"`
}

// RegisterProjectFieldDeleteTool registers the gh project field-delete tool
func RegisterProjectFieldDeleteTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_project_field_delete",
		Description: "Delete a field in a project",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ProjectFieldDeleteArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"project", "field-delete"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.Id != "" {
			cmd = append(cmd, "--id", args.Id)
		}

		if args.Format != "" {
			cmd = append(cmd, "--format", args.Format)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh project field-delete failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ProjectItemListArgs defines parameters for gh project item-list
type ProjectItemListArgs struct {
	Owner    string `json:"owner,omitempty" jsonschema:"description=Login of the owner (use @me for current user),required"`
	Limit    int    `json:"limit,omitempty" jsonschema:"description=Maximum number of items to fetch"`
	Format   string `json:"format,omitempty" jsonschema:"description=Output format,enum=json"`
	Jq       string `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Template string `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`

	Number string `json:"number,omitempty" jsonschema:"description=Project number (positional),required"`
}

// RegisterProjectItemListTool registers the gh project item-list tool
func RegisterProjectItemListTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_project_item_list",
		Description: "List the items in a project",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ProjectItemListArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"project", "item-list"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.Limit > 0 {
			cmd = append(cmd, "--limit", fmt.Sprintf("%d", args.Limit))
		}

		if args.Format != "" {
			cmd = append(cmd, "--format", args.Format)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh project item-list failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ProjectItemAddArgs defines parameters for gh project item-add
type ProjectItemAddArgs struct {
	Owner    string `json:"owner,omitempty" jsonschema:"description=Login of the owner (use @me for current user),required"`
	Url      string `json:"url,omitempty" jsonschema:"description=URL of the issue or pull request to add,required"`
	Format   string `json:"format,omitempty" jsonschema:"description=Output format,enum=json"`
	Jq       string `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Template string `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`

	Number string `json:"number,omitempty" jsonschema:"description=Project number (positional),required"`
}

// RegisterProjectItemAddTool registers the gh project item-add tool
func RegisterProjectItemAddTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_project_item_add",
		Description: "Add a pull request or issue to a project",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ProjectItemAddArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"project", "item-add"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.Url != "" {
			cmd = append(cmd, "--url", args.Url)
		}

		if args.Format != "" {
			cmd = append(cmd, "--format", args.Format)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh project item-add failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ProjectItemCreateArgs defines parameters for gh project item-create
type ProjectItemCreateArgs struct {
	Owner  string `json:"owner,omitempty" jsonschema:"description=Login of the owner (use @me for current user),required"`
	Title  string `json:"title,omitempty" jsonschema:"description=Title of the draft issue,required"`
	Body   string `json:"body,omitempty" jsonschema:"description=Body of the draft issue"`
	Format string `json:"format,omitempty" jsonschema:"description=Output format,enum=json"`

	Number string `json:"number,omitempty" jsonschema:"description=Project number (positional),required"`
}

// RegisterProjectItemCreateTool registers the gh project item-create tool
func RegisterProjectItemCreateTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_project_item_create",
		Description: "Create a draft issue item in a project",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ProjectItemCreateArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"project", "item-create"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.Title != "" {
			cmd = append(cmd, "--title", args.Title)
		}

		if args.Body != "" {
			cmd = append(cmd, "--body", args.Body)
		}

		if args.Format != "" {
			cmd = append(cmd, "--format", args.Format)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh project item-create failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ProjectItemEditArgs defines parameters for gh project item-edit
type ProjectItemEditArgs struct {
	Owner                string `json:"owner,omitempty" jsonschema:"description=Login of the owner (use @me for current user),required"`
	Id                   string `json:"id,omitempty" jsonschema:"description=ID of the item to edit,required"`
	FieldId              string `json:"field_id,omitempty" jsonschema:"description=ID of the field to update"`
	Text                 string `json:"text,omitempty" jsonschema:"description=Text value for the field"`
	NumberValue          string `json:"number_value,omitempty" jsonschema:"description=Number value for the field"`
	Date                 string `json:"date,omitempty" jsonschema:"description=Date value for the field (YYYY-MM-DD)"`
	SingleSelectOptionId string `json:"single_select_option_id,omitempty" jsonschema:"description=ID of the single select option value"`
	IterationId          string `json:"iteration_id,omitempty" jsonschema:"description=ID of the iteration value"`
	Clear                bool   `json:"clear,omitempty" jsonschema:"description=Clear the field value"`
	Format               string `json:"format,omitempty" jsonschema:"description=Output format,enum=json"`

	Number string `json:"number,omitempty" jsonschema:"description=Project number (positional),required"`
}

// RegisterProjectItemEditTool registers the gh project item-edit tool
func RegisterProjectItemEditTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_project_item_edit",
		Description: "Edit an item in a project",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ProjectItemEditArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"project", "item-edit"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.Id != "" {
			cmd = append(cmd, "--id", args.Id)
		}

		if args.FieldId != "" {
			cmd = append(cmd, "--field-id", args.FieldId)
		}

		if args.Text != "" {
			cmd = append(cmd, "--text", args.Text)
		}

		if args.NumberValue != "" {
			cmd = append(cmd, "--number", args.NumberValue)
		}

		if args.Date != "" {
			cmd = append(cmd, "--date", args.Date)
		}

		if args.SingleSelectOptionId != "" {
			cmd = append(cmd, "--single-select-option-id", args.SingleSelectOptionId)
		}

		if args.IterationId != "" {
			cmd = append(cmd, "--iteration-id", args.IterationId)
		}

		if args.Clear {
			cmd = append(cmd, "--clear")
		}

		if args.Format != "" {
			cmd = append(cmd, "--format", args.Format)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh project item-edit failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ProjectItemDeleteArgs defines parameters for gh project item-delete
type ProjectItemDeleteArgs struct {
	Owner  string `json:"owner,omitempty" jsonschema:"description=Login of the owner (use @me for current user),required"`
	Id     string `json:"id,omitempty" jsonschema:"description=ID of the item to delete,required"`
	Format string `json:"format,omitempty" jsonschema:"description=Output format,enum=json"`

	Number string `json:"number,omitempty" jsonschema:"description=Project number (positional),required"`
}

// RegisterProjectItemDeleteTool registers the gh project item-delete tool
func RegisterProjectItemDeleteTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_project_item_delete",
		Description: "Delete an item from a project",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ProjectItemDeleteArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"project", "item-delete"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.Id != "" {
			cmd = append(cmd, "--id", args.Id)
		}

		if args.Format != "" {
			cmd = append(cmd, "--format", args.Format)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh project item-delete failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ProjectItemArchiveArgs defines parameters for gh project item-archive
type ProjectItemArchiveArgs struct {
	Owner  string `json:"owner,omitempty" jsonschema:"description=Login of the owner (use @me for current user),required"`
	Id     string `json:"id,omitempty" jsonschema:"description=ID of the item to archive,required"`
	Undo   bool   `json:"undo,omitempty" jsonschema:"description=Unarchive an item"`
	Format string `json:"format,omitempty" jsonschema:"description=Output format,enum=json"`

	Number string `json:"number,omitempty" jsonschema:"description=Project number (positional),required"`
}

// RegisterProjectItemArchiveTool registers the gh project item-archive tool
func RegisterProjectItemArchiveTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_project_item_archive",
		Description: "Archive an item in a project",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ProjectItemArchiveArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"project", "item-archive"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.Id != "" {
			cmd = append(cmd, "--id", args.Id)
		}

		if args.Undo {
			cmd = append(cmd, "--undo")
		}

		if args.Format != "" {
			cmd = append(cmd, "--format", args.Format)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh project item-archive failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ProjectLinkArgs defines parameters for gh project link
type ProjectLinkArgs struct {
	Owner  string `json:"owner,omitempty" jsonschema:"description=Login of the owner (use @me for current user),required"`
	Repo   string `json:"repo,omitempty" jsonschema:"description=Repository to link to the project (OWNER/REPO)"`
	Team   string `json:"team,omitempty" jsonschema:"description=Team to link to the project (ORG/TEAM)"`
	Format string `json:"format,omitempty" jsonschema:"description=Output format,enum=json"`

	Number string `json:"number,omitempty" jsonschema:"description=Project number (positional),required"`
}

// RegisterProjectLinkTool registers the gh project link tool
func RegisterProjectLinkTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_project_link",
		Description: "Link a project to a repository or team",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ProjectLinkArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"project", "link"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		if args.Team != "" {
			cmd = append(cmd, "--team", args.Team)
		}

		if args.Format != "" {
			cmd = append(cmd, "--format", args.Format)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh project link failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ProjectUnlinkArgs defines parameters for gh project unlink
type ProjectUnlinkArgs struct {
	Owner  string `json:"owner,omitempty" jsonschema:"description=Login of the owner (use @me for current user),required"`
	Repo   string `json:"repo,omitempty" jsonschema:"description=Repository to unlink from the project (OWNER/REPO)"`
	Team   string `json:"team,omitempty" jsonschema:"description=Team to unlink from the project (ORG/TEAM)"`
	Format string `json:"format,omitempty" jsonschema:"description=Output format,enum=json"`

	Number string `json:"number,omitempty" jsonschema:"description=Project number (positional),required"`
}

// RegisterProjectUnlinkTool registers the gh project unlink tool
func RegisterProjectUnlinkTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_project_unlink",
		Description: "Unlink a project from a repository or team",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ProjectUnlinkArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"project", "unlink"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		if args.Team != "" {
			cmd = append(cmd, "--team", args.Team)
		}

		if args.Format != "" {
			cmd = append(cmd, "--format", args.Format)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh project unlink failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ProjectMarkTemplateArgs defines parameters for gh project mark-template
type ProjectMarkTemplateArgs struct {
	Owner  string `json:"owner,omitempty" jsonschema:"description=Login of the owner (use @me for current user),required"`
	Undo   bool   `json:"undo,omitempty" jsonschema:"description=Unmark the project as a template"`
	Format string `json:"format,omitempty" jsonschema:"description=Output format,enum=json"`

	Number string `json:"number,omitempty" jsonschema:"description=Project number (positional),required"`
}

// RegisterProjectMarkTemplateTool registers the gh project mark-template tool
func RegisterProjectMarkTemplateTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_project_mark_template",
		Description: "Mark a project as a template",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ProjectMarkTemplateArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"project", "mark-template"}

		// Add positional argument: number
		if args.Number != "" {
			cmd = append(cmd, args.Number)
		}

		if args.Owner != "" {
			cmd = append(cmd, "--owner", args.Owner)
		}

		if args.Undo {
			cmd = append(cmd, "--undo")
		}

		if args.Format != "" {
			cmd = append(cmd, "--format", args.Format)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh project mark-template failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
