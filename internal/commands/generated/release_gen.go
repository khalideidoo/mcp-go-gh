// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalideidoo/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// ReleaseCreateArgs defines parameters for gh release create
type ReleaseCreateArgs struct {
	Draft              bool   `json:"draft,omitempty" jsonschema:"Save the release as a draft"`
	GenerateNotes      bool   `json:"generate_notes,omitempty" jsonschema:"Automatically generate title and notes"`
	Latest             bool   `json:"latest,omitempty" jsonschema:"Mark as latest release"`
	Notes              string `json:"notes,omitempty" jsonschema:"Release notes"`
	NotesFile          string `json:"notes_file,omitempty" jsonschema:"Read release notes from file"`
	NotesStartTag      string `json:"notes_start_tag,omitempty" jsonschema:"Tag to use as the starting point for notes"`
	Prerelease         bool   `json:"prerelease,omitempty" jsonschema:"Mark as a prerelease"`
	Target             string `json:"target,omitempty" jsonschema:"Target branch or commit SHA"`
	Title              string `json:"title,omitempty" jsonschema:"Release title"`
	VerifyTag          bool   `json:"verify_tag,omitempty" jsonschema:"Abort if the git tag doesn't exist"`
	DiscussionCategory string `json:"discussion_category,omitempty" jsonschema:"Start a discussion in the specified category"`
	Repo               string `json:"repo,omitempty" jsonschema:"Select repository"`

	Tag string `json:"tag,omitempty" jsonschema:"Tag name (positional argument)"`
}

// RegisterReleaseCreateTool registers the gh release create tool
func RegisterReleaseCreateTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_release_create",
		Description: "Create a new release",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ReleaseCreateArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"release", "create"}

		// Add positional argument: tag
		if args.Tag != "" {
			cmd = append(cmd, args.Tag)
		}

		if args.Draft {
			cmd = append(cmd, "--draft")
		}

		if args.GenerateNotes {
			cmd = append(cmd, "--generate-notes")
		}

		if args.Latest {
			cmd = append(cmd, "--latest")
		}

		if args.Notes != "" {
			cmd = append(cmd, "--notes", args.Notes)
		}

		if args.NotesFile != "" {
			cmd = append(cmd, "--notes-file", args.NotesFile)
		}

		if args.NotesStartTag != "" {
			cmd = append(cmd, "--notes-start-tag", args.NotesStartTag)
		}

		if args.Prerelease {
			cmd = append(cmd, "--prerelease")
		}

		if args.Target != "" {
			cmd = append(cmd, "--target", args.Target)
		}

		if args.Title != "" {
			cmd = append(cmd, "--title", args.Title)
		}

		if args.VerifyTag {
			cmd = append(cmd, "--verify-tag")
		}

		if args.DiscussionCategory != "" {
			cmd = append(cmd, "--discussion-category", args.DiscussionCategory)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh release create failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ReleaseListArgs defines parameters for gh release list
type ReleaseListArgs struct {
	ExcludeDrafts      bool     `json:"exclude_drafts,omitempty" jsonschema:"Exclude draft releases"`
	ExcludePreReleases bool     `json:"exclude_pre_releases,omitempty" jsonschema:"Exclude pre-releases"`
	Limit              int      `json:"limit,omitempty" jsonschema:"Maximum number of items to fetch"`
	Json               []string `json:"json,omitempty" jsonschema:"Output JSON with the specified fields"`
	Jq                 string   `json:"jq,omitempty" jsonschema:"Filter JSON output using a jq expression"`
	Template           string   `json:"template,omitempty" jsonschema:"Format JSON output using a Go template"`
	Repo               string   `json:"repo,omitempty" jsonschema:"Select repository"`
}

// RegisterReleaseListTool registers the gh release list tool
func RegisterReleaseListTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_release_list",
		Description: "List releases in a repository",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ReleaseListArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"release", "list"}

		if args.ExcludeDrafts {
			cmd = append(cmd, "--exclude-drafts")
		}

		if args.ExcludePreReleases {
			cmd = append(cmd, "--exclude-pre-releases")
		}

		if args.Limit > 0 {
			cmd = append(cmd, "--limit", fmt.Sprintf("%d", args.Limit))
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh release list failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ReleaseViewArgs defines parameters for gh release view
type ReleaseViewArgs struct {
	Json     []string `json:"json,omitempty" jsonschema:"Output JSON with the specified fields"`
	Jq       string   `json:"jq,omitempty" jsonschema:"Filter JSON output using a jq expression"`
	Template string   `json:"template,omitempty" jsonschema:"Format JSON output using a Go template"`
	Web      bool     `json:"web,omitempty" jsonschema:"Open the release in the browser"`
	Repo     string   `json:"repo,omitempty" jsonschema:"Select repository"`

	Tag string `json:"tag,omitempty" jsonschema:"The tag name or 'latest' (positional argument)"`
}

// RegisterReleaseViewTool registers the gh release view tool
func RegisterReleaseViewTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_release_view",
		Description: "View information about a release",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ReleaseViewArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"release", "view"}

		// Add positional argument: tag
		if args.Tag != "" {
			cmd = append(cmd, args.Tag)
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh release view failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ReleaseDeleteArgs defines parameters for gh release delete
type ReleaseDeleteArgs struct {
	CleanupTag bool   `json:"cleanup_tag,omitempty" jsonschema:"Delete the associated git tag"`
	Yes        bool   `json:"yes,omitempty" jsonschema:"Skip the confirmation prompt"`
	Repo       string `json:"repo,omitempty" jsonschema:"Select repository"`

	Tag string `json:"tag,omitempty" jsonschema:"Tag name (positional argument)"`
}

// RegisterReleaseDeleteTool registers the gh release delete tool
func RegisterReleaseDeleteTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_release_delete",
		Description: "Delete a release",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ReleaseDeleteArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"release", "delete"}

		// Add positional argument: tag
		if args.Tag != "" {
			cmd = append(cmd, args.Tag)
		}

		if args.CleanupTag {
			cmd = append(cmd, "--cleanup-tag")
		}

		if args.Yes {
			cmd = append(cmd, "--yes")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh release delete failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ReleaseDownloadArgs defines parameters for gh release download
type ReleaseDownloadArgs struct {
	Archive      string   `json:"archive,omitempty" jsonschema:"Download archive format"`
	Clobber      bool     `json:"clobber,omitempty" jsonschema:"Overwrite existing files"`
	Dir          string   `json:"dir,omitempty" jsonschema:"Directory to download files into"`
	Output       string   `json:"output,omitempty" jsonschema:"Save a single asset to a file"`
	Pattern      []string `json:"pattern,omitempty" jsonschema:"Download only assets matching glob pattern"`
	SkipExisting bool     `json:"skip_existing,omitempty" jsonschema:"Skip downloading files that exist"`
	Repo         string   `json:"repo,omitempty" jsonschema:"Select repository"`

	Tag string `json:"tag,omitempty" jsonschema:"The tag name or 'latest' (positional argument)"`
}

// RegisterReleaseDownloadTool registers the gh release download tool
func RegisterReleaseDownloadTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_release_download",
		Description: "Download release assets",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ReleaseDownloadArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"release", "download"}

		// Add positional argument: tag
		if args.Tag != "" {
			cmd = append(cmd, args.Tag)
		}

		if args.Archive != "" {
			cmd = append(cmd, "--archive", args.Archive)
		}

		if args.Clobber {
			cmd = append(cmd, "--clobber")
		}

		if args.Dir != "" {
			cmd = append(cmd, "--dir", args.Dir)
		}

		if args.Output != "" {
			cmd = append(cmd, "--output", args.Output)
		}

		for _, v := range args.Pattern {
			cmd = append(cmd, "--pattern", v)
		}

		if args.SkipExisting {
			cmd = append(cmd, "--skip-existing")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh release download failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ReleaseUploadArgs defines parameters for gh release upload
type ReleaseUploadArgs struct {
	Clobber bool   `json:"clobber,omitempty" jsonschema:"Overwrite existing assets"`
	Repo    string `json:"repo,omitempty" jsonschema:"Select repository"`

	Tag    string   `json:"tag,omitempty" jsonschema:"Tag name (positional argument)"`
	Assets []string `json:"assets,omitempty" jsonschema:"Asset files to upload (positional arguments)"`
}

// RegisterReleaseUploadTool registers the gh release upload tool
func RegisterReleaseUploadTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_release_upload",
		Description: "Upload assets to a release",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ReleaseUploadArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"release", "upload"}

		// Add positional argument: tag
		if args.Tag != "" {
			cmd = append(cmd, args.Tag)
		}

		// Add positional argument: assets
		cmd = append(cmd, args.Assets...)

		if args.Clobber {
			cmd = append(cmd, "--clobber")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh release upload failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// ReleaseEditArgs defines parameters for gh release edit
type ReleaseEditArgs struct {
	Draft              bool   `json:"draft,omitempty" jsonschema:"Mark release as a draft"`
	Latest             bool   `json:"latest,omitempty" jsonschema:"Mark as the latest release"`
	Notes              string `json:"notes,omitempty" jsonschema:"Release notes"`
	NotesFile          string `json:"notes_file,omitempty" jsonschema:"Read release notes from file"`
	Prerelease         bool   `json:"prerelease,omitempty" jsonschema:"Mark as a prerelease"`
	TagName            string `json:"tag_name,omitempty" jsonschema:"Target tag to edit"`
	Target             string `json:"target,omitempty" jsonschema:"Target branch or commit SHA"`
	Title              string `json:"title,omitempty" jsonschema:"Release title"`
	DiscussionCategory string `json:"discussion_category,omitempty" jsonschema:"Discussion category"`
	VerifyTag          bool   `json:"verify_tag,omitempty" jsonschema:"Verify the git tag exists"`
	Repo               string `json:"repo,omitempty" jsonschema:"Select repository"`

	Tag string `json:"tag,omitempty" jsonschema:"Tag name (positional argument)"`
}

// RegisterReleaseEditTool registers the gh release edit tool
func RegisterReleaseEditTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_release_edit",
		Description: "Edit a release",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args ReleaseEditArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"release", "edit"}

		// Add positional argument: tag
		if args.Tag != "" {
			cmd = append(cmd, args.Tag)
		}

		if args.Draft {
			cmd = append(cmd, "--draft")
		}

		if args.Latest {
			cmd = append(cmd, "--latest")
		}

		if args.Notes != "" {
			cmd = append(cmd, "--notes", args.Notes)
		}

		if args.NotesFile != "" {
			cmd = append(cmd, "--notes-file", args.NotesFile)
		}

		if args.Prerelease {
			cmd = append(cmd, "--prerelease")
		}

		if args.TagName != "" {
			cmd = append(cmd, "--tag", args.TagName)
		}

		if args.Target != "" {
			cmd = append(cmd, "--target", args.Target)
		}

		if args.Title != "" {
			cmd = append(cmd, "--title", args.Title)
		}

		if args.DiscussionCategory != "" {
			cmd = append(cmd, "--discussion-category", args.DiscussionCategory)
		}

		if args.VerifyTag {
			cmd = append(cmd, "--verify-tag")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh release edit failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
