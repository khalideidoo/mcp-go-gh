// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalideidoo/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// RepoCreateArgs defines parameters for gh repo create
type RepoCreateArgs struct {
	Clone         bool   `json:"clone,omitempty" jsonschema:"description=Clone the new repository to the current directory"`
	Description   string `json:"description,omitempty" jsonschema:"description=Description of the repository"`
	Homepage      string `json:"homepage,omitempty" jsonschema:"description=Repository home page URL"`
	Team          string `json:"team,omitempty" jsonschema:"description=The name of the organization team to grant access"`
	Template      string `json:"template,omitempty" jsonschema:"description=Make the new repository based on a template repository"`
	Public        bool   `json:"public,omitempty" jsonschema:"description=Make the new repository public"`
	Private       bool   `json:"private,omitempty" jsonschema:"description=Make the new repository private"`
	Internal      bool   `json:"internal,omitempty" jsonschema:"description=Make the new repository internal"`
	DisableIssues bool   `json:"disable_issues,omitempty" jsonschema:"description=Disable issues in the new repository"`
	DisableWiki   bool   `json:"disable_wiki,omitempty" jsonschema:"description=Disable wiki in the new repository"`
	Gitignore     string `json:"gitignore,omitempty" jsonschema:"description=Specify a gitignore template for the repository"`
	License       string `json:"license,omitempty" jsonschema:"description=Specify an Open Source License for the repository"`
	Push          bool   `json:"push,omitempty" jsonschema:"description=Push local commits to the new repository"`
	Source        string `json:"source,omitempty" jsonschema:"description=Specify path to local repository to use as source"`
	Remote        string `json:"remote,omitempty" jsonschema:"description=Specify remote name for the new repository"`
	AddReadme     bool   `json:"add_readme,omitempty" jsonschema:"description=Add a README file to the new repository"`

	Name string `json:"name,omitempty" jsonschema:"description=Name of the repository (positional argument)"`
}

// RegisterRepoCreateTool registers the gh repo create tool
func RegisterRepoCreateTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_repo_create",
		Description: "Create a new repository",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args RepoCreateArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"repo", "create"}

		// Add positional argument: name
		if args.Name != "" {
			cmd = append(cmd, args.Name)
		}

		if args.Clone {
			cmd = append(cmd, "--clone")
		}

		if args.Description != "" {
			cmd = append(cmd, "--description", args.Description)
		}

		if args.Homepage != "" {
			cmd = append(cmd, "--homepage", args.Homepage)
		}

		if args.Team != "" {
			cmd = append(cmd, "--team", args.Team)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Public {
			cmd = append(cmd, "--public")
		}

		if args.Private {
			cmd = append(cmd, "--private")
		}

		if args.Internal {
			cmd = append(cmd, "--internal")
		}

		if args.DisableIssues {
			cmd = append(cmd, "--disable-issues")
		}

		if args.DisableWiki {
			cmd = append(cmd, "--disable-wiki")
		}

		if args.Gitignore != "" {
			cmd = append(cmd, "--gitignore", args.Gitignore)
		}

		if args.License != "" {
			cmd = append(cmd, "--license", args.License)
		}

		if args.Push {
			cmd = append(cmd, "--push")
		}

		if args.Source != "" {
			cmd = append(cmd, "--source", args.Source)
		}

		if args.Remote != "" {
			cmd = append(cmd, "--remote", args.Remote)
		}

		if args.AddReadme {
			cmd = append(cmd, "--add-readme")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh repo create failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// RepoListArgs defines parameters for gh repo list
type RepoListArgs struct {
	Archived   bool     `json:"archived,omitempty" jsonschema:"description=Show only archived repositories"`
	Fork       bool     `json:"fork,omitempty" jsonschema:"description=Show only forked repositories"`
	Source     bool     `json:"source,omitempty" jsonschema:"description=Show only non-forked repositories"`
	Language   string   `json:"language,omitempty" jsonschema:"description=Filter by primary coding language"`
	Limit      int      `json:"limit,omitempty" jsonschema:"description=Maximum number of repositories to list"`
	NoArchived bool     `json:"no_archived,omitempty" jsonschema:"description=Omit archived repositories"`
	Topic      string   `json:"topic,omitempty" jsonschema:"description=Filter by topic"`
	Visibility string   `json:"visibility,omitempty" jsonschema:"description=Filter by visibility,enum=public,enum=private,enum=internal"`
	Json       []string `json:"json,omitempty" jsonschema:"description=Output JSON with the specified fields"`
	Jq         string   `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Template   string   `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`

	Owner string `json:"owner,omitempty" jsonschema:"description=Owner (user or organization) (positional argument)"`
}

// RegisterRepoListTool registers the gh repo list tool
func RegisterRepoListTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_repo_list",
		Description: "List repositories owned by user or organization",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args RepoListArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"repo", "list"}

		// Add positional argument: owner
		if args.Owner != "" {
			cmd = append(cmd, args.Owner)
		}

		if args.Archived {
			cmd = append(cmd, "--archived")
		}

		if args.Fork {
			cmd = append(cmd, "--fork")
		}

		if args.Source {
			cmd = append(cmd, "--source")
		}

		if args.Language != "" {
			cmd = append(cmd, "--language", args.Language)
		}

		if args.Limit > 0 {
			cmd = append(cmd, "--limit", fmt.Sprintf("%d", args.Limit))
		}

		if args.NoArchived {
			cmd = append(cmd, "--no-archived")
		}

		if args.Topic != "" {
			cmd = append(cmd, "--topic", args.Topic)
		}

		if args.Visibility != "" {
			cmd = append(cmd, "--visibility", args.Visibility)
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh repo list failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// RepoViewArgs defines parameters for gh repo view
type RepoViewArgs struct {
	Branch   string   `json:"branch,omitempty" jsonschema:"description=View a specific branch of the repository"`
	Json     []string `json:"json,omitempty" jsonschema:"description=Output JSON with the specified fields"`
	Jq       string   `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Template string   `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`
	Web      bool     `json:"web,omitempty" jsonschema:"description=Open repository in the browser"`

	Repository string `json:"repository,omitempty" jsonschema:"description=Repository to view (OWNER/REPO or URL) (positional argument)"`
}

// RegisterRepoViewTool registers the gh repo view tool
func RegisterRepoViewTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_repo_view",
		Description: "View a repository",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args RepoViewArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"repo", "view"}

		// Add positional argument: repository
		if args.Repository != "" {
			cmd = append(cmd, args.Repository)
		}

		if args.Branch != "" {
			cmd = append(cmd, "--branch", args.Branch)
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh repo view failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// RepoCloneArgs defines parameters for gh repo clone
type RepoCloneArgs struct {
	Depth             int  `json:"depth,omitempty" jsonschema:"description=Create a shallow clone with history truncated"`
	RecurseSubmodules bool `json:"recurse_submodules,omitempty" jsonschema:"description=Clone with submodules"`

	Repository string `json:"repository,omitempty" jsonschema:"description=Repository to clone (OWNER/REPO or URL) (positional argument),required"`
	Directory  string `json:"directory,omitempty" jsonschema:"description=Directory to clone into (positional argument)"`
}

// RegisterRepoCloneTool registers the gh repo clone tool
func RegisterRepoCloneTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_repo_clone",
		Description: "Clone a repository locally",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args RepoCloneArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"repo", "clone"}

		// Add positional argument: repository
		if args.Repository != "" {
			cmd = append(cmd, args.Repository)
		}

		// Add positional argument: directory
		if args.Directory != "" {
			cmd = append(cmd, args.Directory)
		}

		if args.Depth > 0 {
			cmd = append(cmd, "--depth", fmt.Sprintf("%d", args.Depth))
		}

		if args.RecurseSubmodules {
			cmd = append(cmd, "--recurse-submodules")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh repo clone failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// RepoForkArgs defines parameters for gh repo fork
type RepoForkArgs struct {
	Clone             bool   `json:"clone,omitempty" jsonschema:"description=Clone the fork"`
	DefaultBranchOnly bool   `json:"default_branch_only,omitempty" jsonschema:"description=Only include the default branch"`
	ForkName          string `json:"fork_name,omitempty" jsonschema:"description=Rename the forked repository"`
	Org               string `json:"org,omitempty" jsonschema:"description=Create the fork in an organization"`
	Remote            bool   `json:"remote,omitempty" jsonschema:"description=Add a git remote for the fork"`
	RemoteName        string `json:"remote_name,omitempty" jsonschema:"description=Specify the remote name"`

	Repository string `json:"repository,omitempty" jsonschema:"description=Repository to fork (OWNER/REPO or URL) (positional argument)"`
}

// RegisterRepoForkTool registers the gh repo fork tool
func RegisterRepoForkTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_repo_fork",
		Description: "Create a fork of a repository",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args RepoForkArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"repo", "fork"}

		// Add positional argument: repository
		if args.Repository != "" {
			cmd = append(cmd, args.Repository)
		}

		if args.Clone {
			cmd = append(cmd, "--clone")
		}

		if args.DefaultBranchOnly {
			cmd = append(cmd, "--default-branch-only")
		}

		if args.ForkName != "" {
			cmd = append(cmd, "--fork-name", args.ForkName)
		}

		if args.Org != "" {
			cmd = append(cmd, "--org", args.Org)
		}

		if args.Remote {
			cmd = append(cmd, "--remote")
		}

		if args.RemoteName != "" {
			cmd = append(cmd, "--remote-name", args.RemoteName)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh repo fork failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// RepoDeleteArgs defines parameters for gh repo delete
type RepoDeleteArgs struct {
	Yes bool `json:"yes,omitempty" jsonschema:"description=Skip the confirmation prompt"`

	Repository string `json:"repository,omitempty" jsonschema:"description=Repository to delete (OWNER/REPO) (positional argument),required"`
}

// RegisterRepoDeleteTool registers the gh repo delete tool
func RegisterRepoDeleteTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_repo_delete",
		Description: "Delete a repository",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args RepoDeleteArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"repo", "delete"}

		// Add positional argument: repository
		if args.Repository != "" {
			cmd = append(cmd, args.Repository)
		}

		if args.Yes {
			cmd = append(cmd, "--yes")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh repo delete failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// RepoArchiveArgs defines parameters for gh repo archive
type RepoArchiveArgs struct {
	Yes  bool   `json:"yes,omitempty" jsonschema:"description=Skip the confirmation prompt"`
	Repo string `json:"repo,omitempty" jsonschema:"description=Select repository"`

	Repository string `json:"repository,omitempty" jsonschema:"description=Repository to archive (OWNER/REPO) (positional argument)"`
}

// RegisterRepoArchiveTool registers the gh repo archive tool
func RegisterRepoArchiveTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_repo_archive",
		Description: "Archive a repository",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args RepoArchiveArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"repo", "archive"}

		// Add positional argument: repository
		if args.Repository != "" {
			cmd = append(cmd, args.Repository)
		}

		if args.Yes {
			cmd = append(cmd, "--yes")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh repo archive failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// RepoUnarchiveArgs defines parameters for gh repo unarchive
type RepoUnarchiveArgs struct {
	Yes  bool   `json:"yes,omitempty" jsonschema:"description=Skip the confirmation prompt"`
	Repo string `json:"repo,omitempty" jsonschema:"description=Select repository"`

	Repository string `json:"repository,omitempty" jsonschema:"description=Repository to unarchive (OWNER/REPO) (positional argument)"`
}

// RegisterRepoUnarchiveTool registers the gh repo unarchive tool
func RegisterRepoUnarchiveTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_repo_unarchive",
		Description: "Unarchive a repository",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args RepoUnarchiveArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"repo", "unarchive"}

		// Add positional argument: repository
		if args.Repository != "" {
			cmd = append(cmd, args.Repository)
		}

		if args.Yes {
			cmd = append(cmd, "--yes")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh repo unarchive failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// RepoEditArgs defines parameters for gh repo edit
type RepoEditArgs struct {
	AddTopic            []string `json:"add_topic,omitempty" jsonschema:"description=Add repository topic"`
	RemoveTopic         []string `json:"remove_topic,omitempty" jsonschema:"description=Remove repository topic"`
	AllowForking        bool     `json:"allow_forking,omitempty" jsonschema:"description=Allow forking"`
	DefaultBranch       string   `json:"default_branch,omitempty" jsonschema:"description=Set the default branch name"`
	DeleteBranchOnMerge bool     `json:"delete_branch_on_merge,omitempty" jsonschema:"description=Delete head branch on merge"`
	Description         string   `json:"description,omitempty" jsonschema:"description=Repository description"`
	EnableAutoMerge     bool     `json:"enable_auto_merge,omitempty" jsonschema:"description=Enable auto-merge"`
	EnableDiscussions   bool     `json:"enable_discussions,omitempty" jsonschema:"description=Enable discussions"`
	EnableIssues        bool     `json:"enable_issues,omitempty" jsonschema:"description=Enable issues"`
	EnableMergeCommit   bool     `json:"enable_merge_commit,omitempty" jsonschema:"description=Enable merge commits"`
	EnableProjects      bool     `json:"enable_projects,omitempty" jsonschema:"description=Enable projects"`
	EnableRebaseMerge   bool     `json:"enable_rebase_merge,omitempty" jsonschema:"description=Enable rebase merging"`
	EnableSquashMerge   bool     `json:"enable_squash_merge,omitempty" jsonschema:"description=Enable squash merging"`
	EnableWiki          bool     `json:"enable_wiki,omitempty" jsonschema:"description=Enable wiki"`
	Homepage            string   `json:"homepage,omitempty" jsonschema:"description=Repository home page URL"`
	Template            bool     `json:"template,omitempty" jsonschema:"description=Make the repository a template"`
	Visibility          string   `json:"visibility,omitempty" jsonschema:"description=Repository visibility,enum=public,enum=private,enum=internal"`
	Repo                string   `json:"repo,omitempty" jsonschema:"description=Select repository"`

	Repository string `json:"repository,omitempty" jsonschema:"description=Repository to edit (OWNER/REPO) (positional argument)"`
}

// RegisterRepoEditTool registers the gh repo edit tool
func RegisterRepoEditTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_repo_edit",
		Description: "Edit repository settings",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args RepoEditArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"repo", "edit"}

		// Add positional argument: repository
		if args.Repository != "" {
			cmd = append(cmd, args.Repository)
		}

		for _, v := range args.AddTopic {
			cmd = append(cmd, "--add-topic", v)
		}

		for _, v := range args.RemoveTopic {
			cmd = append(cmd, "--remove-topic", v)
		}

		if args.AllowForking {
			cmd = append(cmd, "--allow-forking")
		}

		if args.DefaultBranch != "" {
			cmd = append(cmd, "--default-branch", args.DefaultBranch)
		}

		if args.DeleteBranchOnMerge {
			cmd = append(cmd, "--delete-branch-on-merge")
		}

		if args.Description != "" {
			cmd = append(cmd, "--description", args.Description)
		}

		if args.EnableAutoMerge {
			cmd = append(cmd, "--enable-auto-merge")
		}

		if args.EnableDiscussions {
			cmd = append(cmd, "--enable-discussions")
		}

		if args.EnableIssues {
			cmd = append(cmd, "--enable-issues")
		}

		if args.EnableMergeCommit {
			cmd = append(cmd, "--enable-merge-commit")
		}

		if args.EnableProjects {
			cmd = append(cmd, "--enable-projects")
		}

		if args.EnableRebaseMerge {
			cmd = append(cmd, "--enable-rebase-merge")
		}

		if args.EnableSquashMerge {
			cmd = append(cmd, "--enable-squash-merge")
		}

		if args.EnableWiki {
			cmd = append(cmd, "--enable-wiki")
		}

		if args.Homepage != "" {
			cmd = append(cmd, "--homepage", args.Homepage)
		}

		if args.Template {
			cmd = append(cmd, "--template")
		}

		if args.Visibility != "" {
			cmd = append(cmd, "--visibility", args.Visibility)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh repo edit failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// RepoRenameArgs defines parameters for gh repo rename
type RepoRenameArgs struct {
	Yes  bool   `json:"yes,omitempty" jsonschema:"description=Skip confirmation prompt"`
	Repo string `json:"repo,omitempty" jsonschema:"description=Select repository"`

	NewName string `json:"new_name,omitempty" jsonschema:"description=New name for the repository (positional argument),required"`
}

// RegisterRepoRenameTool registers the gh repo rename tool
func RegisterRepoRenameTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_repo_rename",
		Description: "Rename a repository",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args RepoRenameArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"repo", "rename"}

		// Add positional argument: new_name
		if args.NewName != "" {
			cmd = append(cmd, args.NewName)
		}

		if args.Yes {
			cmd = append(cmd, "--yes")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh repo rename failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// RepoSyncArgs defines parameters for gh repo sync
type RepoSyncArgs struct {
	Source string `json:"source,omitempty" jsonschema:"description=Source repository (OWNER/REPO)"`
	Branch string `json:"branch,omitempty" jsonschema:"description=Branch to sync"`
	Force  bool   `json:"force,omitempty" jsonschema:"description=Hard reset if source diverged"`
	Repo   string `json:"repo,omitempty" jsonschema:"description=Select repository"`
}

// RegisterRepoSyncTool registers the gh repo sync tool
func RegisterRepoSyncTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_repo_sync",
		Description: "Sync a repository",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args RepoSyncArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"repo", "sync"}

		if args.Source != "" {
			cmd = append(cmd, "--source", args.Source)
		}

		if args.Branch != "" {
			cmd = append(cmd, "--branch", args.Branch)
		}

		if args.Force {
			cmd = append(cmd, "--force")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh repo sync failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
