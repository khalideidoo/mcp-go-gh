// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalideidoo/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// RunListArgs defines parameters for gh run list
type RunListArgs struct {
	Branch   string   `json:"branch,omitempty" jsonschema:"Filter runs by branch"`
	Commit   string   `json:"commit,omitempty" jsonschema:"Filter runs by commit SHA"`
	Created  string   `json:"created,omitempty" jsonschema:"Filter by creation date"`
	Event    string   `json:"event,omitempty" jsonschema:"Filter runs by event type"`
	Limit    int      `json:"limit,omitempty" jsonschema:"Maximum number of runs to fetch"`
	Status   string   `json:"status,omitempty" jsonschema:"Filter by status"`
	User     string   `json:"user,omitempty" jsonschema:"Filter by user who triggered run"`
	Workflow string   `json:"workflow,omitempty" jsonschema:"Filter by workflow"`
	Json     []string `json:"json,omitempty" jsonschema:"Output JSON with the specified fields"`
	Jq       string   `json:"jq,omitempty" jsonschema:"Filter JSON output using a jq expression"`
	Template string   `json:"template,omitempty" jsonschema:"Format JSON output using a Go template"`
	Repo     string   `json:"repo,omitempty" jsonschema:"Select repository"`
}

// RegisterRunListTool registers the gh run list tool
func RegisterRunListTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_run_list",
		Description: "List recent workflow runs",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args RunListArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"run", "list"}

		if args.Branch != "" {
			cmd = append(cmd, "--branch", args.Branch)
		}

		if args.Commit != "" {
			cmd = append(cmd, "--commit", args.Commit)
		}

		if args.Created != "" {
			cmd = append(cmd, "--created", args.Created)
		}

		if args.Event != "" {
			cmd = append(cmd, "--event", args.Event)
		}

		if args.Limit > 0 {
			cmd = append(cmd, "--limit", fmt.Sprintf("%d", args.Limit))
		}

		if args.Status != "" {
			cmd = append(cmd, "--status", args.Status)
		}

		if args.User != "" {
			cmd = append(cmd, "--user", args.User)
		}

		if args.Workflow != "" {
			cmd = append(cmd, "--workflow", args.Workflow)
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh run list failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// RunViewArgs defines parameters for gh run view
type RunViewArgs struct {
	Attempt    int      `json:"attempt,omitempty" jsonschema:"Show specific attempt number"`
	ExitStatus bool     `json:"exit_status,omitempty" jsonschema:"Exit with non-zero status if run failed"`
	Job        string   `json:"job,omitempty" jsonschema:"View specific job ID"`
	Log        bool     `json:"log,omitempty" jsonschema:"View full log"`
	LogFailed  bool     `json:"log_failed,omitempty" jsonschema:"View log for failed steps"`
	Verbose    bool     `json:"verbose,omitempty" jsonschema:"Show more information"`
	Web        bool     `json:"web,omitempty" jsonschema:"Open run in the browser"`
	Json       []string `json:"json,omitempty" jsonschema:"Output JSON with the specified fields"`
	Jq         string   `json:"jq,omitempty" jsonschema:"Filter JSON output using a jq expression"`
	Template   string   `json:"template,omitempty" jsonschema:"Format JSON output using a Go template"`
	Repo       string   `json:"repo,omitempty" jsonschema:"Select repository"`

	RunId string `json:"run_id,omitempty" jsonschema:"Run ID or number (positional argument)"`
}

// RegisterRunViewTool registers the gh run view tool
func RegisterRunViewTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_run_view",
		Description: "View a summary of a workflow run",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args RunViewArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"run", "view"}

		// Add positional argument: run_id
		if args.RunId != "" {
			cmd = append(cmd, args.RunId)
		}

		if args.Attempt > 0 {
			cmd = append(cmd, "--attempt", fmt.Sprintf("%d", args.Attempt))
		}

		if args.ExitStatus {
			cmd = append(cmd, "--exit-status")
		}

		if args.Job != "" {
			cmd = append(cmd, "--job", args.Job)
		}

		if args.Log {
			cmd = append(cmd, "--log")
		}

		if args.LogFailed {
			cmd = append(cmd, "--log-failed")
		}

		if args.Verbose {
			cmd = append(cmd, "--verbose")
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh run view failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// RunWatchArgs defines parameters for gh run watch
type RunWatchArgs struct {
	ExitStatus bool   `json:"exit_status,omitempty" jsonschema:"Exit with non-zero status if run fails"`
	Interval   int    `json:"interval,omitempty" jsonschema:"Refresh interval in seconds"`
	Repo       string `json:"repo,omitempty" jsonschema:"Select repository"`

	RunId string `json:"run_id,omitempty" jsonschema:"Run ID or number (positional argument)"`
}

// RegisterRunWatchTool registers the gh run watch tool
func RegisterRunWatchTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_run_watch",
		Description: "Watch a run until it completes",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args RunWatchArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"run", "watch"}

		// Add positional argument: run_id
		if args.RunId != "" {
			cmd = append(cmd, args.RunId)
		}

		if args.ExitStatus {
			cmd = append(cmd, "--exit-status")
		}

		if args.Interval > 0 {
			cmd = append(cmd, "--interval", fmt.Sprintf("%d", args.Interval))
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh run watch failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// RunRerunArgs defines parameters for gh run rerun
type RunRerunArgs struct {
	Debug  bool   `json:"debug,omitempty" jsonschema:"Rerun with debug logging"`
	Failed bool   `json:"failed,omitempty" jsonschema:"Rerun only failed jobs"`
	Job    string `json:"job,omitempty" jsonschema:"Rerun specific job ID"`
	Repo   string `json:"repo,omitempty" jsonschema:"Select repository"`

	RunId string `json:"run_id,omitempty" jsonschema:"Run ID or number (positional argument)"`
}

// RegisterRunRerunTool registers the gh run rerun tool
func RegisterRunRerunTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_run_rerun",
		Description: "Rerun a run",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args RunRerunArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"run", "rerun"}

		// Add positional argument: run_id
		if args.RunId != "" {
			cmd = append(cmd, args.RunId)
		}

		if args.Debug {
			cmd = append(cmd, "--debug")
		}

		if args.Failed {
			cmd = append(cmd, "--failed")
		}

		if args.Job != "" {
			cmd = append(cmd, "--job", args.Job)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh run rerun failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// RunCancelArgs defines parameters for gh run cancel
type RunCancelArgs struct {
	Repo string `json:"repo,omitempty" jsonschema:"Select repository"`

	RunId string `json:"run_id,omitempty" jsonschema:"Run ID or number (positional argument)"`
}

// RegisterRunCancelTool registers the gh run cancel tool
func RegisterRunCancelTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_run_cancel",
		Description: "Cancel a workflow run",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args RunCancelArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"run", "cancel"}

		// Add positional argument: run_id
		if args.RunId != "" {
			cmd = append(cmd, args.RunId)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh run cancel failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// RunDeleteArgs defines parameters for gh run delete
type RunDeleteArgs struct {
	Repo string `json:"repo,omitempty" jsonschema:"Select repository"`

	RunId string `json:"run_id,omitempty" jsonschema:"Run ID or number (positional argument)"`
}

// RegisterRunDeleteTool registers the gh run delete tool
func RegisterRunDeleteTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_run_delete",
		Description: "Delete a workflow run",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args RunDeleteArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"run", "delete"}

		// Add positional argument: run_id
		if args.RunId != "" {
			cmd = append(cmd, args.RunId)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh run delete failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// RunDownloadArgs defines parameters for gh run download
type RunDownloadArgs struct {
	Dir     string   `json:"dir,omitempty" jsonschema:"Download directory"`
	Name    []string `json:"name,omitempty" jsonschema:"Download specific artifacts by name"`
	Pattern []string `json:"pattern,omitempty" jsonschema:"Download artifacts matching pattern"`
	Repo    string   `json:"repo,omitempty" jsonschema:"Select repository"`

	RunId string `json:"run_id,omitempty" jsonschema:"Run ID or number (positional argument)"`
}

// RegisterRunDownloadTool registers the gh run download tool
func RegisterRunDownloadTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_run_download",
		Description: "Download artifacts from a run",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args RunDownloadArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"run", "download"}

		// Add positional argument: run_id
		if args.RunId != "" {
			cmd = append(cmd, args.RunId)
		}

		if args.Dir != "" {
			cmd = append(cmd, "--dir", args.Dir)
		}

		for _, v := range args.Name {
			cmd = append(cmd, "--name", v)
		}

		for _, v := range args.Pattern {
			cmd = append(cmd, "--pattern", v)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh run download failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
