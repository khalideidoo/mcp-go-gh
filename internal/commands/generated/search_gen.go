// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalideidoo/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// SearchReposArgs defines parameters for gh search repos
type SearchReposArgs struct {
	Archived         bool     `json:"archived,omitempty" jsonschema:"Include archived repositories"`
	Created          string   `json:"created,omitempty" jsonschema:"Filter by creation date"`
	Followers        string   `json:"followers,omitempty" jsonschema:"Filter by number of followers"`
	Forks            string   `json:"forks,omitempty" jsonschema:"Filter by number of forks"`
	GoodFirstIssue   string   `json:"good_first_issue,omitempty" jsonschema:"Filter by number of good first issues"`
	HelpWantedIssues string   `json:"help_wanted_issues,omitempty" jsonschema:"Filter by number of help wanted issues"`
	IncludeForks     string   `json:"include_forks,omitempty" jsonschema:"Include forks"`
	Language         string   `json:"language,omitempty" jsonschema:"Filter by programming language"`
	License          []string `json:"license,omitempty" jsonschema:"Filter by license"`
	Match            string   `json:"match,omitempty" jsonschema:"Restrict search to specific field"`
	NumberTopics     string   `json:"number_topics,omitempty" jsonschema:"Filter by number of topics"`
	Order            string   `json:"order,omitempty" jsonschema:"Order of results"`
	Owner            []string `json:"owner,omitempty" jsonschema:"Filter by owner"`
	Size             string   `json:"size,omitempty" jsonschema:"Filter by size in KB"`
	Sort             string   `json:"sort,omitempty" jsonschema:"Sort results"`
	Stars            string   `json:"stars,omitempty" jsonschema:"Filter by number of stars"`
	Topic            []string `json:"topic,omitempty" jsonschema:"Filter by topic"`
	Updated          string   `json:"updated,omitempty" jsonschema:"Filter by last update date"`
	Visibility       []string `json:"visibility,omitempty" jsonschema:"Filter by visibility"`
	Limit            int      `json:"limit,omitempty" jsonschema:"Maximum number of results"`
	Json             []string `json:"json,omitempty" jsonschema:"Output JSON with the specified fields"`
	Jq               string   `json:"jq,omitempty" jsonschema:"Filter JSON output using a jq expression"`
	Template         string   `json:"template,omitempty" jsonschema:"Format JSON output using a Go template"`
	Web              bool     `json:"web,omitempty" jsonschema:"Open search in browser"`

	Query string `json:"query,omitempty" jsonschema:"Search query (positional argument)"`
}

// RegisterSearchReposTool registers the gh search repos tool
func RegisterSearchReposTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_search_repos",
		Description: "Search for repositories",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args SearchReposArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"search", "repos"}

		// Add positional argument: query
		if args.Query != "" {
			cmd = append(cmd, args.Query)
		}

		if args.Archived {
			cmd = append(cmd, "--archived")
		}

		if args.Created != "" {
			cmd = append(cmd, "--created", args.Created)
		}

		if args.Followers != "" {
			cmd = append(cmd, "--followers", args.Followers)
		}

		if args.Forks != "" {
			cmd = append(cmd, "--forks", args.Forks)
		}

		if args.GoodFirstIssue != "" {
			cmd = append(cmd, "--good-first-issue", args.GoodFirstIssue)
		}

		if args.HelpWantedIssues != "" {
			cmd = append(cmd, "--help-wanted-issues", args.HelpWantedIssues)
		}

		if args.IncludeForks != "" {
			cmd = append(cmd, "--include-forks", args.IncludeForks)
		}

		if args.Language != "" {
			cmd = append(cmd, "--language", args.Language)
		}

		for _, v := range args.License {
			cmd = append(cmd, "--license", v)
		}

		if args.Match != "" {
			cmd = append(cmd, "--match", args.Match)
		}

		if args.NumberTopics != "" {
			cmd = append(cmd, "--number-topics", args.NumberTopics)
		}

		if args.Order != "" {
			cmd = append(cmd, "--order", args.Order)
		}

		for _, v := range args.Owner {
			cmd = append(cmd, "--owner", v)
		}

		if args.Size != "" {
			cmd = append(cmd, "--size", args.Size)
		}

		if args.Sort != "" {
			cmd = append(cmd, "--sort", args.Sort)
		}

		if args.Stars != "" {
			cmd = append(cmd, "--stars", args.Stars)
		}

		for _, v := range args.Topic {
			cmd = append(cmd, "--topic", v)
		}

		if args.Updated != "" {
			cmd = append(cmd, "--updated", args.Updated)
		}

		for _, v := range args.Visibility {
			cmd = append(cmd, "--visibility", v)
		}

		if args.Limit > 0 {
			cmd = append(cmd, "--limit", fmt.Sprintf("%d", args.Limit))
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh search repos failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// SearchIssuesArgs defines parameters for gh search issues
type SearchIssuesArgs struct {
	Assignee    string   `json:"assignee,omitempty" jsonschema:"Filter by assignee"`
	Author      string   `json:"author,omitempty" jsonschema:"Filter by author"`
	Closed      string   `json:"closed,omitempty" jsonschema:"Filter by closed date"`
	Comments    string   `json:"comments,omitempty" jsonschema:"Filter by number of comments"`
	Created     string   `json:"created,omitempty" jsonschema:"Filter by created date"`
	IncludePrs  bool     `json:"include_prs,omitempty" jsonschema:"Include pull requests"`
	Label       []string `json:"label,omitempty" jsonschema:"Filter by label"`
	Locked      bool     `json:"locked,omitempty" jsonschema:"Filter by locked status"`
	Match       string   `json:"match,omitempty" jsonschema:"Restrict search to specific field"`
	Mentions    string   `json:"mentions,omitempty" jsonschema:"Filter by user mentions"`
	Milestone   string   `json:"milestone,omitempty" jsonschema:"Filter by milestone"`
	NoAssignee  bool     `json:"no_assignee,omitempty" jsonschema:"Filter by missing assignee"`
	NoLabel     bool     `json:"no_label,omitempty" jsonschema:"Filter by missing label"`
	NoMilestone bool     `json:"no_milestone,omitempty" jsonschema:"Filter by missing milestone"`
	NoProject   bool     `json:"no_project,omitempty" jsonschema:"Filter by missing project"`
	Order       string   `json:"order,omitempty" jsonschema:"Order of results"`
	Owner       []string `json:"owner,omitempty" jsonschema:"Filter by repository owner"`
	Repo        []string `json:"repo,omitempty" jsonschema:"Filter by repository"`
	Sort        string   `json:"sort,omitempty" jsonschema:"Sort results"`
	State       string   `json:"state,omitempty" jsonschema:"Filter by state"`
	Updated     string   `json:"updated,omitempty" jsonschema:"Filter by updated date"`
	Limit       int      `json:"limit,omitempty" jsonschema:"Maximum number of results"`
	Json        []string `json:"json,omitempty" jsonschema:"Output JSON with the specified fields"`
	Jq          string   `json:"jq,omitempty" jsonschema:"Filter JSON output using a jq expression"`
	Template    string   `json:"template,omitempty" jsonschema:"Format JSON output using a Go template"`
	Web         bool     `json:"web,omitempty" jsonschema:"Open search in browser"`

	Query string `json:"query,omitempty" jsonschema:"Search query (positional argument)"`
}

// RegisterSearchIssuesTool registers the gh search issues tool
func RegisterSearchIssuesTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_search_issues",
		Description: "Search for issues",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args SearchIssuesArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"search", "issues"}

		// Add positional argument: query
		if args.Query != "" {
			cmd = append(cmd, args.Query)
		}

		if args.Assignee != "" {
			cmd = append(cmd, "--assignee", args.Assignee)
		}

		if args.Author != "" {
			cmd = append(cmd, "--author", args.Author)
		}

		if args.Closed != "" {
			cmd = append(cmd, "--closed", args.Closed)
		}

		if args.Comments != "" {
			cmd = append(cmd, "--comments", args.Comments)
		}

		if args.Created != "" {
			cmd = append(cmd, "--created", args.Created)
		}

		if args.IncludePrs {
			cmd = append(cmd, "--include-prs")
		}

		for _, v := range args.Label {
			cmd = append(cmd, "--label", v)
		}

		if args.Locked {
			cmd = append(cmd, "--locked")
		}

		if args.Match != "" {
			cmd = append(cmd, "--match", args.Match)
		}

		if args.Mentions != "" {
			cmd = append(cmd, "--mentions", args.Mentions)
		}

		if args.Milestone != "" {
			cmd = append(cmd, "--milestone", args.Milestone)
		}

		if args.NoAssignee {
			cmd = append(cmd, "--no-assignee")
		}

		if args.NoLabel {
			cmd = append(cmd, "--no-label")
		}

		if args.NoMilestone {
			cmd = append(cmd, "--no-milestone")
		}

		if args.NoProject {
			cmd = append(cmd, "--no-project")
		}

		if args.Order != "" {
			cmd = append(cmd, "--order", args.Order)
		}

		for _, v := range args.Owner {
			cmd = append(cmd, "--owner", v)
		}

		for _, v := range args.Repo {
			cmd = append(cmd, "--repo", v)
		}

		if args.Sort != "" {
			cmd = append(cmd, "--sort", args.Sort)
		}

		if args.State != "" {
			cmd = append(cmd, "--state", args.State)
		}

		if args.Updated != "" {
			cmd = append(cmd, "--updated", args.Updated)
		}

		if args.Limit > 0 {
			cmd = append(cmd, "--limit", fmt.Sprintf("%d", args.Limit))
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh search issues failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// SearchPrsArgs defines parameters for gh search prs
type SearchPrsArgs struct {
	Archived   bool     `json:"archived,omitempty" jsonschema:"Filter by archived repositories"`
	Assignee   string   `json:"assignee,omitempty" jsonschema:"Filter by assignee"`
	Author     string   `json:"author,omitempty" jsonschema:"Filter by author"`
	Base       string   `json:"base,omitempty" jsonschema:"Filter by base branch"`
	Closed     string   `json:"closed,omitempty" jsonschema:"Filter by closed date"`
	Comments   string   `json:"comments,omitempty" jsonschema:"Filter by number of comments"`
	Created    string   `json:"created,omitempty" jsonschema:"Filter by created date"`
	Draft      bool     `json:"draft,omitempty" jsonschema:"Filter by draft PRs"`
	Head       string   `json:"head,omitempty" jsonschema:"Filter by head branch"`
	Label      []string `json:"label,omitempty" jsonschema:"Filter by label"`
	Locked     bool     `json:"locked,omitempty" jsonschema:"Filter by locked status"`
	Match      string   `json:"match,omitempty" jsonschema:"Restrict search to specific field"`
	Merged     bool     `json:"merged,omitempty" jsonschema:"Filter by merged PRs"`
	MergedAt   string   `json:"merged_at,omitempty" jsonschema:"Filter by merge date"`
	Milestone  string   `json:"milestone,omitempty" jsonschema:"Filter by milestone"`
	Order      string   `json:"order,omitempty" jsonschema:"Order of results"`
	Owner      []string `json:"owner,omitempty" jsonschema:"Filter by repository owner"`
	Repo       []string `json:"repo,omitempty" jsonschema:"Filter by repository"`
	Review     string   `json:"review,omitempty" jsonschema:"Filter by review status"`
	ReviewedBy string   `json:"reviewed_by,omitempty" jsonschema:"Filter by reviewer"`
	Sort       string   `json:"sort,omitempty" jsonschema:"Sort results"`
	State      string   `json:"state,omitempty" jsonschema:"Filter by state"`
	TeamReview string   `json:"team_review,omitempty" jsonschema:"Filter by team requested to review"`
	Updated    string   `json:"updated,omitempty" jsonschema:"Filter by updated date"`
	Limit      int      `json:"limit,omitempty" jsonschema:"Maximum number of results"`
	Json       []string `json:"json,omitempty" jsonschema:"Output JSON with the specified fields"`
	Jq         string   `json:"jq,omitempty" jsonschema:"Filter JSON output using a jq expression"`
	Template   string   `json:"template,omitempty" jsonschema:"Format JSON output using a Go template"`
	Web        bool     `json:"web,omitempty" jsonschema:"Open search in browser"`

	Query string `json:"query,omitempty" jsonschema:"Search query (positional argument)"`
}

// RegisterSearchPrsTool registers the gh search prs tool
func RegisterSearchPrsTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_search_prs",
		Description: "Search for pull requests",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args SearchPrsArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"search", "prs"}

		// Add positional argument: query
		if args.Query != "" {
			cmd = append(cmd, args.Query)
		}

		if args.Archived {
			cmd = append(cmd, "--archived")
		}

		if args.Assignee != "" {
			cmd = append(cmd, "--assignee", args.Assignee)
		}

		if args.Author != "" {
			cmd = append(cmd, "--author", args.Author)
		}

		if args.Base != "" {
			cmd = append(cmd, "--base", args.Base)
		}

		if args.Closed != "" {
			cmd = append(cmd, "--closed", args.Closed)
		}

		if args.Comments != "" {
			cmd = append(cmd, "--comments", args.Comments)
		}

		if args.Created != "" {
			cmd = append(cmd, "--created", args.Created)
		}

		if args.Draft {
			cmd = append(cmd, "--draft")
		}

		if args.Head != "" {
			cmd = append(cmd, "--head", args.Head)
		}

		for _, v := range args.Label {
			cmd = append(cmd, "--label", v)
		}

		if args.Locked {
			cmd = append(cmd, "--locked")
		}

		if args.Match != "" {
			cmd = append(cmd, "--match", args.Match)
		}

		if args.Merged {
			cmd = append(cmd, "--merged")
		}

		if args.MergedAt != "" {
			cmd = append(cmd, "--merged-at", args.MergedAt)
		}

		if args.Milestone != "" {
			cmd = append(cmd, "--milestone", args.Milestone)
		}

		if args.Order != "" {
			cmd = append(cmd, "--order", args.Order)
		}

		for _, v := range args.Owner {
			cmd = append(cmd, "--owner", v)
		}

		for _, v := range args.Repo {
			cmd = append(cmd, "--repo", v)
		}

		if args.Review != "" {
			cmd = append(cmd, "--review", args.Review)
		}

		if args.ReviewedBy != "" {
			cmd = append(cmd, "--reviewed-by", args.ReviewedBy)
		}

		if args.Sort != "" {
			cmd = append(cmd, "--sort", args.Sort)
		}

		if args.State != "" {
			cmd = append(cmd, "--state", args.State)
		}

		if args.TeamReview != "" {
			cmd = append(cmd, "--team-review", args.TeamReview)
		}

		if args.Updated != "" {
			cmd = append(cmd, "--updated", args.Updated)
		}

		if args.Limit > 0 {
			cmd = append(cmd, "--limit", fmt.Sprintf("%d", args.Limit))
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh search prs failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
