// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalideidoo/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// SecretListArgs defines parameters for gh secret list
type SecretListArgs struct {
	App      string   `json:"app,omitempty" jsonschema:"List secrets for Actions or Dependabot"`
	Env      string   `json:"env,omitempty" jsonschema:"List secrets for an environment"`
	Org      string   `json:"org,omitempty" jsonschema:"List secrets for an organization"`
	User     bool     `json:"user,omitempty" jsonschema:"List user secrets"`
	Json     []string `json:"json,omitempty" jsonschema:"Output JSON with the specified fields"`
	Jq       string   `json:"jq,omitempty" jsonschema:"Filter JSON output using a jq expression"`
	Template string   `json:"template,omitempty" jsonschema:"Format JSON output using a Go template"`
	Repo     string   `json:"repo,omitempty" jsonschema:"Select repository"`
}

// RegisterSecretListTool registers the gh secret list tool
func RegisterSecretListTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_secret_list",
		Description: "List secrets",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args SecretListArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"secret", "list"}

		if args.App != "" {
			cmd = append(cmd, "--app", args.App)
		}

		if args.Env != "" {
			cmd = append(cmd, "--env", args.Env)
		}

		if args.Org != "" {
			cmd = append(cmd, "--org", args.Org)
		}

		if args.User {
			cmd = append(cmd, "--user")
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh secret list failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// SecretSetArgs defines parameters for gh secret set
type SecretSetArgs struct {
	App        string   `json:"app,omitempty" jsonschema:"Set secret for Actions or Dependabot"`
	Body       string   `json:"body,omitempty" jsonschema:"Secret value (reads from STDIN if not specified)"`
	BodyFile   string   `json:"body_file,omitempty" jsonschema:"Read secret value from file"`
	Env        string   `json:"env,omitempty" jsonschema:"Set secret for an environment"`
	NoStore    bool     `json:"no_store,omitempty" jsonschema:"Do not store secret in org/repo secret manager"`
	Org        string   `json:"org,omitempty" jsonschema:"Set organization secret"`
	Repos      []string `json:"repos,omitempty" jsonschema:"List of repositories with access (org secrets only)"`
	User       bool     `json:"user,omitempty" jsonschema:"Set user secret"`
	Visibility string   `json:"visibility,omitempty" jsonschema:"Secret visibility (org secrets only)"`
	Repo       string   `json:"repo,omitempty" jsonschema:"Select repository"`

	SecretName string `json:"secret_name,omitempty" jsonschema:"Name of the secret (positional argument)"`
}

// RegisterSecretSetTool registers the gh secret set tool
func RegisterSecretSetTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_secret_set",
		Description: "Create or update secrets",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args SecretSetArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"secret", "set"}

		// Add positional argument: secret_name
		if args.SecretName != "" {
			cmd = append(cmd, args.SecretName)
		}

		if args.App != "" {
			cmd = append(cmd, "--app", args.App)
		}

		if args.Body != "" {
			cmd = append(cmd, "--body", args.Body)
		}

		if args.BodyFile != "" {
			cmd = append(cmd, "--body-file", args.BodyFile)
		}

		if args.Env != "" {
			cmd = append(cmd, "--env", args.Env)
		}

		if args.NoStore {
			cmd = append(cmd, "--no-store")
		}

		if args.Org != "" {
			cmd = append(cmd, "--org", args.Org)
		}

		for _, v := range args.Repos {
			cmd = append(cmd, "--repos", v)
		}

		if args.User {
			cmd = append(cmd, "--user")
		}

		if args.Visibility != "" {
			cmd = append(cmd, "--visibility", args.Visibility)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh secret set failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// SecretRemoveArgs defines parameters for gh secret remove
type SecretRemoveArgs struct {
	App  string `json:"app,omitempty" jsonschema:"Remove secret for Actions or Dependabot"`
	Env  string `json:"env,omitempty" jsonschema:"Remove secret from environment"`
	Org  string `json:"org,omitempty" jsonschema:"Remove organization secret"`
	User bool   `json:"user,omitempty" jsonschema:"Remove user secret"`
	Repo string `json:"repo,omitempty" jsonschema:"Select repository"`

	SecretName string `json:"secret_name,omitempty" jsonschema:"Name of the secret (positional argument)"`
}

// RegisterSecretRemoveTool registers the gh secret remove tool
func RegisterSecretRemoveTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_secret_remove",
		Description: "Remove secrets",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args SecretRemoveArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"secret", "remove"}

		// Add positional argument: secret_name
		if args.SecretName != "" {
			cmd = append(cmd, args.SecretName)
		}

		if args.App != "" {
			cmd = append(cmd, "--app", args.App)
		}

		if args.Env != "" {
			cmd = append(cmd, "--env", args.Env)
		}

		if args.Org != "" {
			cmd = append(cmd, "--org", args.Org)
		}

		if args.User {
			cmd = append(cmd, "--user")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh secret remove failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
