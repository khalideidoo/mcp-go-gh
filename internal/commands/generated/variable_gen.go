// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalideidoo/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// VariableSetArgs defines parameters for gh variable set
type VariableSetArgs struct {
	Body       string   `json:"body,omitempty" jsonschema:"description=The value for the variable (reads from stdin if not specified)"`
	EnvFile    string   `json:"env_file,omitempty" jsonschema:"description=Load variable names and values from a dotenv-formatted file"`
	Env        string   `json:"env,omitempty" jsonschema:"description=Set deployment environment variable"`
	Org        string   `json:"org,omitempty" jsonschema:"description=Set organization variable"`
	Repos      []string `json:"repos,omitempty" jsonschema:"description=List of repositories that can access an organization variable"`
	Visibility string   `json:"visibility,omitempty" jsonschema:"description=Set visibility for an organization variable,enum=all,enum=private,enum=selected"`
	Repo       string   `json:"repo,omitempty" jsonschema:"description=Select repository in OWNER/REPO format"`

	VariableName string `json:"variable_name,omitempty" jsonschema:"description=Name of the variable (positional),required"`
}

// RegisterVariableSetTool registers the gh variable set tool
func RegisterVariableSetTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_variable_set",
		Description: "Create or update a variable",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args VariableSetArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"variable", "set"}

		// Add positional argument: variable_name
		if args.VariableName != "" {
			cmd = append(cmd, args.VariableName)
		}

		if args.Body != "" {
			cmd = append(cmd, "--body", args.Body)
		}

		if args.EnvFile != "" {
			cmd = append(cmd, "--env-file", args.EnvFile)
		}

		if args.Env != "" {
			cmd = append(cmd, "--env", args.Env)
		}

		if args.Org != "" {
			cmd = append(cmd, "--org", args.Org)
		}

		for _, v := range args.Repos {
			cmd = append(cmd, "--repos", v)
		}

		if args.Visibility != "" {
			cmd = append(cmd, "--visibility", args.Visibility)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh variable set failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// VariableListArgs defines parameters for gh variable list
type VariableListArgs struct {
	Env      string   `json:"env,omitempty" jsonschema:"description=List variables for an environment"`
	Org      string   `json:"org,omitempty" jsonschema:"description=List variables for an organization"`
	Json     []string `json:"json,omitempty" jsonschema:"description=Output JSON with the specified fields"`
	Jq       string   `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Template string   `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`
	Repo     string   `json:"repo,omitempty" jsonschema:"description=Select repository in OWNER/REPO format"`
}

// RegisterVariableListTool registers the gh variable list tool
func RegisterVariableListTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_variable_list",
		Description: "List variables",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args VariableListArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"variable", "list"}

		if args.Env != "" {
			cmd = append(cmd, "--env", args.Env)
		}

		if args.Org != "" {
			cmd = append(cmd, "--org", args.Org)
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh variable list failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// VariableGetArgs defines parameters for gh variable get
type VariableGetArgs struct {
	Env  string `json:"env,omitempty" jsonschema:"description=Get variable for an environment"`
	Org  string `json:"org,omitempty" jsonschema:"description=Get organization variable"`
	Repo string `json:"repo,omitempty" jsonschema:"description=Select repository in OWNER/REPO format"`

	VariableName string `json:"variable_name,omitempty" jsonschema:"description=Name of the variable (positional),required"`
}

// RegisterVariableGetTool registers the gh variable get tool
func RegisterVariableGetTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_variable_get",
		Description: "Get a variable value",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args VariableGetArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"variable", "get"}

		// Add positional argument: variable_name
		if args.VariableName != "" {
			cmd = append(cmd, args.VariableName)
		}

		if args.Env != "" {
			cmd = append(cmd, "--env", args.Env)
		}

		if args.Org != "" {
			cmd = append(cmd, "--org", args.Org)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh variable get failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// VariableDeleteArgs defines parameters for gh variable delete
type VariableDeleteArgs struct {
	Env  string `json:"env,omitempty" jsonschema:"description=Delete variable from an environment"`
	Org  string `json:"org,omitempty" jsonschema:"description=Delete organization variable"`
	Repo string `json:"repo,omitempty" jsonschema:"description=Select repository in OWNER/REPO format"`

	VariableName string `json:"variable_name,omitempty" jsonschema:"description=Name of the variable (positional),required"`
}

// RegisterVariableDeleteTool registers the gh variable delete tool
func RegisterVariableDeleteTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_variable_delete",
		Description: "Delete a variable",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args VariableDeleteArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"variable", "delete"}

		// Add positional argument: variable_name
		if args.VariableName != "" {
			cmd = append(cmd, args.VariableName)
		}

		if args.Env != "" {
			cmd = append(cmd, "--env", args.Env)
		}

		if args.Org != "" {
			cmd = append(cmd, "--org", args.Org)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh variable delete failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
