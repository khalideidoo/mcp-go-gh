// Code generated by tools/gen. DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"github.com/khalideidoo/mcp-go-gh/internal/executor"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// WorkflowListArgs defines parameters for gh workflow list
type WorkflowListArgs struct {
	All      bool     `json:"all,omitempty" jsonschema:"description=Include disabled workflows"`
	Limit    int      `json:"limit,omitempty" jsonschema:"description=Maximum number of workflows to fetch"`
	Json     []string `json:"json,omitempty" jsonschema:"description=Output JSON with the specified fields"`
	Jq       string   `json:"jq,omitempty" jsonschema:"description=Filter JSON output using a jq expression"`
	Template string   `json:"template,omitempty" jsonschema:"description=Format JSON output using a Go template"`
	Repo     string   `json:"repo,omitempty" jsonschema:"description=Select repository"`
}

// RegisterWorkflowListTool registers the gh workflow list tool
func RegisterWorkflowListTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_workflow_list",
		Description: "List workflow files",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args WorkflowListArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"workflow", "list"}

		if args.All {
			cmd = append(cmd, "--all")
		}

		if args.Limit > 0 {
			cmd = append(cmd, "--limit", fmt.Sprintf("%d", args.Limit))
		}

		for _, v := range args.Json {
			cmd = append(cmd, "--json", v)
		}

		if args.Jq != "" {
			cmd = append(cmd, "--jq", args.Jq)
		}

		if args.Template != "" {
			cmd = append(cmd, "--template", args.Template)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh workflow list failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// WorkflowViewArgs defines parameters for gh workflow view
type WorkflowViewArgs struct {
	Ref  string `json:"ref,omitempty" jsonschema:"description=Branch or tag name to view"`
	Web  bool   `json:"web,omitempty" jsonschema:"description=Open workflow in the browser"`
	Yaml bool   `json:"yaml,omitempty" jsonschema:"description=Output workflow YAML"`
	Repo string `json:"repo,omitempty" jsonschema:"description=Select repository"`

	Workflow string `json:"workflow,omitempty" jsonschema:"description=Workflow ID, name, or filename (positional argument),required"`
}

// RegisterWorkflowViewTool registers the gh workflow view tool
func RegisterWorkflowViewTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_workflow_view",
		Description: "View a workflow",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args WorkflowViewArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"workflow", "view"}

		// Add positional argument: workflow
		if args.Workflow != "" {
			cmd = append(cmd, args.Workflow)
		}

		if args.Ref != "" {
			cmd = append(cmd, "--ref", args.Ref)
		}

		if args.Web {
			cmd = append(cmd, "--web")
		}

		if args.Yaml {
			cmd = append(cmd, "--yaml")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh workflow view failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// WorkflowRunArgs defines parameters for gh workflow run
type WorkflowRunArgs struct {
	Ref      string            `json:"ref,omitempty" jsonschema:"description=Branch or tag name"`
	Field    map[string]string `json:"field,omitempty" jsonschema:"description=Add typed parameter in key=value format"`
	RawField map[string]string `json:"raw_field,omitempty" jsonschema:"description=Add string parameter in key=value format"`
	Json     bool              `json:"json,omitempty" jsonschema:"description=Read workflow inputs as JSON via STDIN"`
	Repo     string            `json:"repo,omitempty" jsonschema:"description=Select repository"`

	Workflow string `json:"workflow,omitempty" jsonschema:"description=Workflow ID, name, or filename (positional argument),required"`
}

// RegisterWorkflowRunTool registers the gh workflow run tool
func RegisterWorkflowRunTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_workflow_run",
		Description: "Run a workflow",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args WorkflowRunArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"workflow", "run"}

		// Add positional argument: workflow
		if args.Workflow != "" {
			cmd = append(cmd, args.Workflow)
		}

		if args.Ref != "" {
			cmd = append(cmd, "--ref", args.Ref)
		}

		for k, v := range args.Field {
			cmd = append(cmd, "-F", fmt.Sprintf("%s=%s", k, v))
		}

		for k, v := range args.RawField {
			cmd = append(cmd, "-f", fmt.Sprintf("%s=%s", k, v))
		}

		if args.Json {
			cmd = append(cmd, "--json")
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh workflow run failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// WorkflowEnableArgs defines parameters for gh workflow enable
type WorkflowEnableArgs struct {
	Repo string `json:"repo,omitempty" jsonschema:"description=Select repository"`

	Workflow string `json:"workflow,omitempty" jsonschema:"description=Workflow ID, name, or filename (positional argument),required"`
}

// RegisterWorkflowEnableTool registers the gh workflow enable tool
func RegisterWorkflowEnableTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_workflow_enable",
		Description: "Enable a workflow",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args WorkflowEnableArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"workflow", "enable"}

		// Add positional argument: workflow
		if args.Workflow != "" {
			cmd = append(cmd, args.Workflow)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh workflow enable failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}

// WorkflowDisableArgs defines parameters for gh workflow disable
type WorkflowDisableArgs struct {
	Repo string `json:"repo,omitempty" jsonschema:"description=Select repository"`

	Workflow string `json:"workflow,omitempty" jsonschema:"description=Workflow ID, name, or filename (positional argument),required"`
}

// RegisterWorkflowDisableTool registers the gh workflow disable tool
func RegisterWorkflowDisableTool(server *mcp.Server, exec *executor.Executor) {
	mcp.AddTool(server, &mcp.Tool{
		Name:        "gh_workflow_disable",
		Description: "Disable a workflow",
	}, func(ctx context.Context, req *mcp.CallToolRequest, args WorkflowDisableArgs) (*mcp.CallToolResult, any, error) {
		cmd := []string{"workflow", "disable"}

		// Add positional argument: workflow
		if args.Workflow != "" {
			cmd = append(cmd, args.Workflow)
		}

		if args.Repo != "" {
			cmd = append(cmd, "--repo", args.Repo)
		}

		result, err := exec.Execute(ctx, cmd...)
		if err != nil {
			return nil, nil, fmt.Errorf("gh workflow disable failed: %w", err)
		}

		return &mcp.CallToolResult{
			Content: []mcp.Content{
				&mcp.TextContent{Text: result.Stdout},
			},
		}, nil, nil
	})
}
